"use strict";(self.webpackChunklearning=self.webpackChunklearning||[]).push([[344],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>m});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),c=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=c(a),m=r,E=d["".concat(s,".").concat(m)]||d[m]||u[m]||l;return a?n.createElement(E,i(i({ref:t},p),{},{components:a})):n.createElement(E,i({ref:t},p))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,i=new Array(l);i[0]=d;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var c=2;c<l;c++)i[c]=a[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},3375:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>l,metadata:()=>o,toc:()=>c});var n=a(7462),r=(a(7294),a(3905));const l={id:"Section 24. Stored Objects",sidebar_position:24,description:"Procedure, Function, Packages"},i=void 0,o={unversionedId:"oracle/Section 24. Stored Objects",id:"oracle/Section 24. Stored Objects",title:"Section 24. Stored Objects",description:"Procedure, Function, Packages",source:"@site/docs/oracle/24_stored_objects.md",sourceDirName:"oracle",slug:"/oracle/Section 24. Stored Objects",permalink:"/learning/docs/oracle/Section 24. Stored Objects",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/oracle/24_stored_objects.md",tags:[],version:"current",sidebarPosition:24,frontMatter:{id:"Section 24. Stored Objects",sidebar_position:24,description:"Procedure, Function, Packages"},sidebar:"tutorialSidebar",previous:{title:"Section 23. Exception Handling",permalink:"/learning/docs/oracle/Section 23. Exception Handling"},next:{title:"Section 25. Collections",permalink:"/learning/docs/oracle/Section 25. Collections"}},s={},c=[{value:"Actual vs. Formal Parameter",id:"actual-vs-formal-parameter",level:2},{value:"Functions",id:"functions",level:2},{value:"Pipelined Function",id:"pipelined-function",level:2},{value:"Stored Procedures",id:"stored-procedures",level:2},{value:"Calling Notations",id:"calling-notations",level:2},{value:"Parameter Modes",id:"parameter-modes",level:2},{value:"NOCOPY",id:"nocopy",level:2},{value:"Procedure Vs. Function",id:"procedure-vs-function",level:2},{value:"PL/SQL Packages",id:"plsql-packages",level:2},{value:"Package Specification",id:"package-specification",level:3},{value:"Package Body",id:"package-body",level:3},{value:"Calling package elements",id:"calling-package-elements",level:3},{value:"One-time only procedure",id:"one-time-only-procedure",level:2},{value:"AUTHID",id:"authid",level:2},{value:"Persistent State of Packages",id:"persistent-state-of-packages",level:2},{value:"PL/SQL Triggers",id:"plsql-triggers",level:2},{value:"Triggering Events:",id:"triggering-events",level:3},{value:"Uses of creating Trigger",id:"uses-of-creating-trigger",level:3},{value:"Order of Execution",id:"order-of-execution",level:3},{value:"Pseudo-records in Trigger",id:"pseudo-records-in-trigger",level:3},{value:"DDL Trigger",id:"ddl-trigger",level:3},{value:"System, User Event Triggers",id:"system-user-event-triggers",level:3},{value:"Instead of Trigger",id:"instead-of-trigger",level:3},{value:"Conditional predicates",id:"conditional-predicates",level:3},{value:"Compound Trigger",id:"compound-trigger",level:3},{value:"Mutating table error",id:"mutating-table-error",level:3}],p={toc:c};function u(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"actual-vs-formal-parameter"},"Actual vs. Formal Parameter"),(0,r.kt)("p",null,"Formal-Parameter defined in the procedure or function.\nActual-Parameter provided by the calling statement to a procedure or function."),(0,r.kt)("h2",{id:"functions"},"Functions"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE [OR REPLACE] FUNCTION function_name (parameter1 datatype, parameter2 datatype,..) --size [VARCHAR2(10)] is not defined;\nRETURN datatype IS --size is not defined\n    --declare variables;\nBEGIN\n    --executable statements;\nRETURN (return_value);\nEND;\n")),(0,r.kt)("h2",{id:"pipelined-function"},"Pipelined Function"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Table function return a table of varray or nested tables"),(0,r.kt)("li",{parentName:"ul"},"Regular tabel function returns after completing the whole data"),(0,r.kt)("li",{parentName:"ul"},"Pipelined functions return each row one by one")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE [OR REPLACE] FUNCTION function_name (parameter1 datatype, parameter2 datatype,..)\nRETURN colleciton_datatype PIPELINED IS\n    --declare variables;\nBEGIN\n    FOR I IN 1..100 LOOP\n        PIPE ROW (object_datatype(value1,value2,..));\n    END LOOP;\n-- RETURN (return_value); -- No need to return any values as we are passing the result in each loop\nRETURN; -- As functions need a return, just return empty\nEND;\n")),(0,r.kt)("h2",{id:"stored-procedures"},"Stored Procedures"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE [OR REPLACE] PROCEDURE procedure_name (parameter1 [IN|OUT|IN OUT] datatype, parameter2..) IS\nBEGIN\n    --executable statements;\nEND [procedure_name];\n")),(0,r.kt)("h2",{id:"calling-notations"},"Calling Notations"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Positional"),"-The datatype and the position if the actual parameter must match with the formal parameter."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Named"),"-The actual parameter is matched with the formal parameter using => symbol"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Mixed"),"-Combination of Positional and Named notations")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE OR REPLACE PROCEDURE greetings(name IN VARCHAR2 ,age IN NUMBER ,place IN VARCHAR2)\nIS\nBEGIN\n    DBMS_OUTPUT.PUT_LINE('Hello:' || name);\n    DBMS_OUTPUT.PUT_LINE('Age:' || age);\n    DBMS_OUTPUT.PUT_LINE('Place:' || place);\nEND greetings;\n/*\nCalling Program\n*/\nEXECUTE greetings('Mohan', 26 ,'Mumbai'); --Positional\n----\nEXECUTE greetings(place=>'Mumbai',name=>'Mohan',age=>26); --Named\n----\nEXECUTE greetings('Mohan',place=>'Mumbai',age=>26); --Mixed -Positioned notations are not allowed after Named notations\n")),(0,r.kt)("h2",{id:"parameter-modes"},"Parameter Modes"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"IN"),": ","[default mode]"," An IN parameter lets you pass a value to the subprogram. It is a read-only parameter. Inside the subprogram, an IN parameter acts like a constant. Its value cannot be changed. IN can have default value; but others cannot. In can pass expressions like (10+5) or constant. But other must be a variable. Parameters are passed by reference."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"OUT"),": An OUT parameter returns a value to the calling program. Its value can be changed. Parameters are passed by value."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"INOUT"),": An INOUT parameter passes an initial value to a subprogram and returns an updated value to the caller. Its value can be changed. Parameters are passed by value.")),(0,r.kt)("h2",{id:"nocopy"},"NOCOPY"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"By default OUT and IN OUT parameters are passed by value and IN parameters are passed by reference."),(0,r.kt)("li",{parentName:"ul"},"When an OUT or IN OUT parameter is modified inside the procedure the procedure actually only modifies a copy of the parameter value."),(0,r.kt)("li",{parentName:"ul"},"Only when the procedure has finished without exception is the result value copied back to the formal parameter."),(0,r.kt)("li",{parentName:"ul"},"Now, if you pass a large collection as an OUT or an IN OUT parameter then it will be passed by value, in other words the entire collection will be copied to the formal parameter when entering the procedure and back again when exiting the procedure."),(0,r.kt)("li",{parentName:"ul"},"If the collection is large this can lead to unnecessary CPU and memory consumption."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"NOCOPY")," hint alleviates this problem because you can use it to instruct the runtime engine to try to pass OUT or IN OUT parameters by reference instead of by value. For example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"PROCEDURE GET_CUSTOMER_ORDERS(\n    P_CUSTOMER_ID IN NUMBER,\n    P_ORDERS OUT NOCOPY ORDERS_COLL\n    );\n\nTHEORDERS ORDERS_COLL;\n\nGET_CUSTOMER_ORDERS(124, THEORDERS);\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"In the absence of the NOCOPY hint the entire orders collection would have been copied into the orders variable upon exit from the procedure."),(0,r.kt)("li",{parentName:"ul"},"Instead the collection is now passed by reference."),(0,r.kt)("li",{parentName:"ul"},"Keep in mind, however, that there is a downside to using NOCOPY."),(0,r.kt)("li",{parentName:"ul"},"When you pass parameters to a procedure by reference then any modifications you perform on the parameters inside the procedure is done on the same memory location as the actual parameter, so the modifications are visible."),(0,r.kt)("li",{parentName:"ul"},"In other words, there is no way to undo or rollback these modifications, even when an exception is raised midway."),(0,r.kt)("li",{parentName:"ul"},"So if an exception is raised inside the procedure the value of the parameter is undefined and cannot be trusted.")),(0,r.kt)("h2",{id:"procedure-vs-function"},"Procedure Vs. Function"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Procedure"),(0,r.kt)("th",{parentName:"tr",align:null},"Function"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Used mainly to a execute certain process"),(0,r.kt)("td",{parentName:"tr",align:null},"Used mainly to perform some calculation")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Cannot call in ",(0,r.kt)("inlineCode",{parentName:"td"},"SELECT")," statement"),(0,r.kt)("td",{parentName:"tr",align:null},"A Function that contains no DML statements can be called in ",(0,r.kt)("inlineCode",{parentName:"td"},"SELECT")," statement")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Use OUT parameter to return the value"),(0,r.kt)("td",{parentName:"tr",align:null},"Use ",(0,r.kt)("inlineCode",{parentName:"td"},"RETURN")," to return the value")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"It is not mandatory to return the value"),(0,r.kt)("td",{parentName:"tr",align:null},"It is mandatory to return the value")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"RETURN")," will simply exit the control from subprogram."),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"RETURN")," will exit the control from subprogram and also returns the value")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Return datatype will not be specified at the time of creation"),(0,r.kt)("td",{parentName:"tr",align:null},"Return datatype is mandatory at the time of creation")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Inputs are used to ",(0,r.kt)("em",{parentName:"td"},"do")," something, rather than ",(0,r.kt)("em",{parentName:"td"},"derive")," something."),(0,r.kt)("td",{parentName:"tr",align:null},'A function takes a set of inputs, and returns something based on those inputs. It "answers a question"')))),(0,r.kt)("h2",{id:"plsql-packages"},"PL/SQL Packages"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Package is a collection of related variables, constants, exceptions, cursors, and subprograms."),(0,r.kt)("li",{parentName:"ul"},"Objects placed in the specification are calledpublic objects."),(0,r.kt)("li",{parentName:"ul"},"Any objects (subprogram or variable) which are not coded in the package specification but coded in the package body is called a private object."),(0,r.kt)("li",{parentName:"ul"},"Only the objects inside the package can call a ",(0,r.kt)("strong",{parentName:"li"},"private object"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Global Variables"),": Global variables can be defined by creating body less package. Whenever a package is loaded, whole package (including variables) will be loaded into the memory for easy access. It won\u2019t be destroyed until the package is complete. These public variables in the package specification can be accessed directly fromother programs. It is useful to declare constants.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE OR REPLACE PACKAGE pkg_var IS\n    v_ttemp number(2):=10;\nEND;\n----\nBEGIN\n    DBMS_OUTPUT.PUT_LINE(pkg_var.v_ttemp);\nEND;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Overloading"),": Packages allow overloading (procedures or functions having same name with different type or different number of parameters) of procedures and functions. Standalone procedures and functions cannot be overloaded."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Forward Declaration"),": If there are any private procedure or functions in the package, as a convention (not mandatory), it can be declared in the beginning of the package body and define it in the later part of the package body."),(0,r.kt)("li",{parentName:"ul"},"Avoid re-compilation of specification. Because, once the specification is compiled, the body and other objects depend on this package become invalid. So they also need to be compiled again to use it."),(0,r.kt)("li",{parentName:"ul"},"The procedures and functions inside the package does not create an object. Object is created for entire package only."),(0,r.kt)("li",{parentName:"ul"},"For local procedure call (inside package), no need to pass parameters because all the variables declared as public (public inside the package or outside) can be accessed anywhere in the package.")),(0,r.kt)("h3",{id:"package-specification"},"Package Specification"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE [OR REPLACE] PACKAGE package_name IS\n    --Declaration of package elements;\n    PROCEDURE procedure_name(param1 datatype,param2 datatype,..);\n    FUNCTION function_name(param1 datatype,param2 datatype,..) RETURN datatype;\nEND [package_name];\n")),(0,r.kt)("h3",{id:"package-body"},"Package Body"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE [OR REPLACE] PACKAGE BODY package_name IS\n    --Declaration of variables\n    --implementation of package elements\n    PROCEDURE procedure_name(param1 datatype,param2 datatype,..) IS\n        --declare variables;\n    BEGIN\n        --executable statements;\n    END procedure_name;\n\n    FUNCTION function_name(param1 datatype,param2 datatype,..)\n    RETURN datatype IS\n        --declare variables;\n    BEGIN\n        --executable statements;\n        RETURN (return_value);\n    END function_name;\n\nEND [package_name];\n")),(0,r.kt)("h3",{id:"calling-package-elements"},"Calling package elements"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"BEGIN\n    package_name.procedure_name(param1,param2..);\n    DBMS_OUTPUT.PUT_LINE(package_name.function_name);\nEND;\n")),(0,r.kt)("h2",{id:"one-time-only-procedure"},"One-time only procedure"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE OR REPLACE PACKAGE BODY package_name IS\n    --Functions, Procedures etc..\nBEGIN\n    --written at the end of package\n    --whatever code is here executes one time only\n    --runs immediately when the package is loaded into the memory\n    --useful for initializing variables like gold rate, USD rate etc.. which changes every day.\nEND package_name; --The END of one time only procedure should be the END of package body. There won't be any separate END for that procedure.\n")),(0,r.kt)("h2",{id:"authid"},"AUTHID"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"AUTHID CURRENT_USER")," is used when you want a piece of code to execute with the privileges of the current user, and not with the privilege of the user who defined the PL/SQL code."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"AUTHID DEFINER")," is exactly opposite to ",(0,r.kt)("inlineCode",{parentName:"li"},"AUTHID CURRENT_USER"),". Using this clause is as same as granting public access to the PL/SQL code."),(0,r.kt)("li",{parentName:"ul"},"If no AUTHID clause is specified Oracle will default to ",(0,r.kt)("inlineCode",{parentName:"li"},"AUTHID DEFINER"),"."),(0,r.kt)("li",{parentName:"ul"},"It is suggestible to set ",(0,r.kt)("inlineCode",{parentName:"li"},"AUTHID")," clause. If not, an intruder may get access to privileges of the definer which an intruder should not get.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE OR REPLACE PROCEDURE create_dept(v_deptno NUMBER)\nAUTHID CURRENT_USER\nIS\nBEGIN\n    INSERT INTO departments VALUES (v_deptno);\nEND;\n")),(0,r.kt)("h2",{id:"persistent-state-of-packages"},"Persistent State of Packages"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"PRAGMA SERIALLY_REUSABLE\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"This pragma is appropriate for packages that declare large temporary work areas that are used once and not needed during subsequent database calls in the same session.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"You can mark a bodiless package as serially reusable. If a package has a spec and body, you must mark both. You cannot mark only the body.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The global memory for serially reusable packages is pooled in the System Global Area (SGA), not allocated to individual users in the User Global Area (UGA). That way, the package work area can be reused. When the call to the server ends, the memory is returned to the pool. Each time the package is reused, its public variables are initialized to their default values or to NULL.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Serially reusable packages cannot be accessed from database triggers or other PL/SQL subprograms that are called from SQL statements. If you try, Oracle generates an error.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The following example creates a serially reusable package:"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE PACKAGE pkg1 IS\n   PRAGMA SERIALLY_REUSABLE;\n   num NUMBER := 0;\n   PROCEDURE init_pkg_state(n NUMBER);\n   PROCEDURE print_pkg_state;\nEND pkg1;\n/\n\nCREATE PACKAGE BODY pkg1 IS\n   PRAGMA SERIALLY_REUSABLE;\n   PROCEDURE init_pkg_state (n NUMBER) IS\n   BEGIN\n      pkg1.num := n;\n   END;\n   PROCEDURE print_pkg_state IS\n   BEGIN\n      dbms_output.put_line('Num: ' || pkg1.num);\n   END;\nEND pkg1;\n/\n")),(0,r.kt)("h2",{id:"plsql-triggers"},"PL/SQL Triggers"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Triggers are stored programs, which are automatically executed or fired implicitly when a triggering events occur. We cannot execute it explicitly."),(0,r.kt)("li",{parentName:"ul"},"Triggers can be enabled or disabled. But stored sub programs cannot."),(0,r.kt)("li",{parentName:"ul"},"Triggers cannot exceed the size limit of 32Kb."),(0,r.kt)("li",{parentName:"ul"},"If a trigger requires many lines of code, consider moving it to a stored procedure that is invoked from the trigger."),(0,r.kt)("li",{parentName:"ul"},"For every trigger a background process is created. It will compromise the performance of the database."),(0,r.kt)("li",{parentName:"ul"},"Triggers cannot span across multiple tables. But views can span across tables."),(0,r.kt)("li",{parentName:"ul"},"A trigger cannot end a transaction directly or indirectly (DDL). Because a trigger is part of a larger transaction. But an autonomous transaction can contain COMMIT and ROLLBACK statements inside a trigger."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Row-Level trigger"),": Fire for each affected row. The old and new values can be seen using this trigger."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Statement-Level trigger"),": Fire for each statement regardless of how many rows are affected. Default trigger is statement level trigger.")),(0,r.kt)("h3",{id:"triggering-events"},"Triggering Events:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"DML Statement")," -Update, Delete, Insert..."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"DDL Statement")," -Create, Alter..."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"System Event")," -Shutdown, Start-Up of database"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"User Event")," -Logon, Logoff")),(0,r.kt)("h3",{id:"uses-of-creating-trigger"},"Uses of creating Trigger"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Enforce business rules"),(0,r.kt)("li",{parentName:"ul"},"Gain strong control over the security"),(0,r.kt)("li",{parentName:"ul"},"Collect statistical information"),(0,r.kt)("li",{parentName:"ul"},"Automatically generate values"),(0,r.kt)("li",{parentName:"ul"},"Prevent invalid transactions")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE [OR REPLACE] TRIGGER trigger_name\n    {BEFORE|AFTER|INSTEAD OF} triggering_event\n    [OF column_name]\n    ON table_name\n    [FOR EACH ROW] --Except for INSTEAD OF triggers, if you omit this clause, then the trigger is a statement trigger.\n    [FOLLOWS another_trigger_name]\n    [ENABLE/DISABLE]\n    [WHEN condition]\nDECLARE\n    --declaration statements\nBEGIN\n    --executable statements\nEND;\n")),(0,r.kt)("h3",{id:"order-of-execution"},"Order of Execution"),(0,r.kt)("p",null,"BEFORE STATEMENT -> BEFORE ROW -> DML -> AFTER ROW -> AFTER STATEMENT"),(0,r.kt)("h3",{id:"pseudo-records-in-trigger"},"Pseudo-records in Trigger"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Operation"),(0,r.kt)("th",{parentName:"tr",align:null},":OLD"),(0,r.kt)("th",{parentName:"tr",align:null},":NEW"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"INSERT"),(0,r.kt)("td",{parentName:"tr",align:null},"NULL"),(0,r.kt)("td",{parentName:"tr",align:null},"Inserted value")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"UPDATE"),(0,r.kt)("td",{parentName:"tr",align:null},"value before update"),(0,r.kt)("td",{parentName:"tr",align:null},"value after update")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"DELETE"),(0,r.kt)("td",{parentName:"tr",align:null},"value before update"),(0,r.kt)("td",{parentName:"tr",align:null},"NULL")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"Ex:\nIF :NEW.sal < :OLD.sal THEN\nDBMS_OUTPUT.PUT_LINE('Salary Increased');\nEND IF;\n")),(0,r.kt)("h3",{id:"ddl-trigger"},"DDL Trigger"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE OR REPLACE TRIGGER tr_schema\nAFTER DDL ON SCHEMA --Trigger for all DLLs for the schema where the trigger is created\nBEGIN\nINSERT INTO schema_audit VALUES(\nSYSDATE,\nSYS_CONTEXT('USERENV','CURRENT_USER'), --user who executed the DDL;\n--sys_context(namespace,paramenter,length)\nORA_DICT_OBJ_TYPE, --system event attribute -type of object where DDL operation occurred\nORA_DICT_OBJ_NAME, --system event attribute -name of the object\nORA_SYSEVENT --system event attribute -which DDL operation\n);\nEND;\n----\nCREATE OR REPLACE TRIGGER tr_schema\nAFTER TRUNCATE ON SCHEMA --for specific DDL; 'DML' does not exist(have to specify individual DML names)\nBEGIN\nINSERT INTO\u2026\nEND;\n----\nCREATE OR REPLACE TRIGGER tr_schema\nAFTER DDL ON DATABASE --for whole Database\nBEGIN\nINSERT INTO\u2026\nEND;\n")),(0,r.kt)("h3",{id:"system-user-event-triggers"},"System, User Event Triggers"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE OR REPLACE TRIGGER tr_logon\nAFTER LOGON ON SCHEMA\nBEGIN\nINSERT INTO hr_event_audit VALUES(\nORA_SYSEVENT, --system event attribute -what system event fired\nSYSDATE\n);\nEND;\n----\nCREATE OR REPLACE TRIGGER tr_logoff\nBEFORE LOGOFF ON SCHEMA\nBEGIN\nINSERT INTO ...\nEND;\n----\nCREATE OR REPLACE TRIGGER tr_logoff\nBEFORE LOGOFF ON DATABASE --sysdba\nBEGIN\nINSERT INTO db_event_audit VALUES(\nUSER); --USER will fetch the username of the logged in db user\nCOMMIT;\nEND;\n----\nCREATE OR REPLACE TRIGGER tr_startup\nAFTER STARTUP ON DATABASE --sysdba privilege needed\nBEGIN\nINSERT INTO \u2026\nEND;\n----\nCREATE OR REPLACE TRIGGER tr_startup\nAFTER SHUTDOWN ON DATABASE --normal or + shutdown only. Won't work on ABORT or database crashes\nBEGIN\nINSERT INTO \u2026\nEND;\n")),(0,r.kt)("h3",{id:"instead-of-trigger"},"Instead of Trigger"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Using Instead of Trigger, you can control the default behavior of Insert, Update, Delete and Merge operations on Views."),(0,r.kt)("li",{parentName:"ul"},"You cannot specify an ",(0,r.kt)("inlineCode",{parentName:"li"},"INSTEAD OF")," trigger on a table."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"INSTEAD OF")," trigger statements are implicitly activated for each row."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"INSTEAD OF")," triggers are valid for DML events on views. They are not valid for DDL or database events.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE OR REPLACE TRIGGER tr_io_insert\nINSTEAD OF INSERT\nON v$employee\nFOR EACH ROW\nBEGIN\n    INSERT INTO employee VALUES(:new.name);\n    INSERT INTO dept VALUES(:new.dname);\nEND;\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE [OR REPLACE] TRIGGER trigger_name\nINSTEAD OF operation\nON view_name\nFOR EACH ROW\nBEGIN\n    --executable statements\nEND;\n")),(0,r.kt)("h3",{id:"conditional-predicates"},"Conditional predicates"),(0,r.kt)("p",null,"These functions helps to know what operation is going on while the trigger is called. It returns Boolean value."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE OR REPLACE TRIGGER tr_employee\nBEFORE INSERT OR DELETE OR UPDATE ON tbl_employee\nFOR EACH ROW\nENABLE\n\nDECLARE\n    v_user VARCHAR2(20);\nBEGIN\n    SELECT user INTO v_user FROM dual;\n    IF INSERTING THEN\n        DBMS_OUTPUT.PUT_LINE('Inserted by:' || v_user);\n    ELSIF DELETING THEN\n        DBMS_OUTPUT.PUT_LINE('Deleted by:' || v_user);\n    ELSIF UPDATING THEN\n        DBMS_OUTPUT.PUT_LINE('Updated by:' || v_user);\n    END IF;\nEND;\n")),(0,r.kt)("h3",{id:"compound-trigger"},"Compound Trigger"),(0,r.kt)("p",null,"The Compound trigger is a trigger that allows you to specify actions for each of four timing points in the single trigger body."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE OR REPLACE TRIGGER trigger_name\nFOR\n    INSERT OR UPDATE\n    ON table_name\n    COMPOUND TRIGGER\n\n    BEFORE STATEMENT IS\n    BEGIN\n        --Execution statements\n    END BEFORE STATEMENT;\n\n    BEFORE EACH ROW IS\n    BEGIN\n        --Execution statements\n    END BEFORE EACH ROW;\n\n    AFTER EACH ROW IS\n    BEGIN\n        --Execution statements\n    END AFTER EACH ROW;\n\n    AFTER STATEMENT IS\n    BEGIN\n        --Execution statements\n    END AFTER STATEMENT;\nEND;\n")),(0,r.kt)("h3",{id:"mutating-table-error"},"Mutating table error"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"This error occurs when we create a row level trigger and attempts to access the same table inside the trigger body."),(0,r.kt)("li",{parentName:"ul"},"Row level cannot read or write to the table from which it is triggering. However, a statement trigger can access.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"/*Only 1 president is allowed in the table*/\nCREATE OR REPLACE PACKAGE presi_pack IS\n    flag NUMBER(1); --Global variable\nEND presi_pack;\n----\nCREATE OR REPLACE TRIGGER presi_check_row\nBEFORE INSERT OR UPDATE OF job ON emp\nFOR EACH ROW\nWHEN(:NEW.job='PRESIDENT')\nBEGIN\n    presi_pack.flag := 1;\nend presi_check_row;\n----\nCREATE OR REPLACE TRIGGER presi_check_stat\nAFTER INSERT OR UPDATE OF job ON emp\nDECLARE\n    presi_count NUMBER(1);\nBEGIN\n    IF presi_pack.flag = 1 THEN\n        presi_pack.flag := 0;\n        SELECT COUNT(1) INTO presi_count FROM emp WHERE job = 'PRESIDENT';\n        IF presi_count > 1 THEN\n            DBMS_OUTPUT.PUT_LINE('More than 1 PRESIDENT');\n        END IF;\n    END IF;\nEND presi_check_stat;\n")))}u.isMDXComponent=!0}}]);
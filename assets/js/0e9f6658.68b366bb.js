"use strict";(self.webpackChunklearning=self.webpackChunklearning||[]).push([[8226],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>p});var a=n(7294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var o=a.createContext({}),d=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=d(e.components);return a.createElement(o.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,i=e.originalType,o=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),c=d(n),p=s,h=c["".concat(o,".").concat(p)]||c[p]||m[p]||i;return n?a.createElement(h,l(l({ref:t},u),{},{components:n})):a.createElement(h,l({ref:t},u))}));function p(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var i=n.length,l=new Array(i);l[0]=c;var r={};for(var o in t)hasOwnProperty.call(t,o)&&(r[o]=t[o]);r.originalType=e,r.mdxType="string"==typeof e?e:s,l[1]=r;for(var d=2;d<i;d++)l[d]=n[d];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},7130:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>m,frontMatter:()=>i,metadata:()=>r,toc:()=>d});var a=n(7462),s=(n(7294),n(3905));const i={id:"Section 16. Index",sidebar_position:16,description:"Index"},l=void 0,r={unversionedId:"oracle/Section 16. Index",id:"oracle/Section 16. Index",title:"Section 16. Index",description:"Index",source:"@site/docs/oracle/16_index.md",sourceDirName:"oracle",slug:"/oracle/Section 16. Index",permalink:"/learning/docs/oracle/Section 16. Index",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/oracle/16_index.md",tags:[],version:"current",sidebarPosition:16,frontMatter:{id:"Section 16. Index",sidebar_position:16,description:"Index"},sidebar:"tutorialSidebar",previous:{title:"Section 15. View",permalink:"/learning/docs/oracle/Section 15. View"},next:{title:"Section 17. Synonym, Sequence",permalink:"/learning/docs/oracle/Section 17. Synonym, Sequence"}},o={},d=[{value:"Index",id:"index",level:2},{value:"B-TREE Indexes (Balanced Tree)",id:"b-tree-indexes-balanced-tree",level:3},{value:"DROP INDEX IF EXISTS",id:"drop-index-if-exists",level:5},{value:"Unique Index",id:"unique-index",level:5},{value:"Specify name for index",id:"specify-name-for-index",level:5},{value:"Function based Index",id:"function-based-index",level:4},{value:"A function-based index has the following main advantages:",id:"a-function-based-index-has-the-following-main-advantages",level:5},{value:"The following are major disadvantages of function-based indexes:",id:"the-following-are-major-disadvantages-of-function-based-indexes",level:5},{value:"Bitmap Index",id:"bitmap-index",level:3},{value:"Bitmap Operations",id:"bitmap-operations",level:4},{value:"When to use Oracle bitmap indexes",id:"when-to-use-oracle-bitmap-indexes",level:4},{value:"To build an execution plan the optimizer checks:",id:"to-build-an-execution-plan-the-optimizer-checks",level:2},{value:"Table Access Paths",id:"table-access-paths",level:2},{value:"Table Access Full (Full Table Scan)",id:"table-access-full-full-table-scan",level:3},{value:"Reasons for Full Table Scan",id:"reasons-for-full-table-scan",level:4},{value:"Table Access by ROWID",id:"table-access-by-rowid",level:3},{value:"Sample Table Scan",id:"sample-table-scan",level:3},{value:"Index Rebuild",id:"index-rebuild",level:2},{value:"Index Compression",id:"index-compression",level:2},{value:"Index Access Paths",id:"index-access-paths",level:2},{value:"Index Unique Scan",id:"index-unique-scan",level:3},{value:"Index Range Scan",id:"index-range-scan",level:3},{value:"Index Full Scan",id:"index-full-scan",level:3},{value:"Index Fast Full Scan",id:"index-fast-full-scan",level:3},{value:"Index Skip Scan",id:"index-skip-scan",level:3},{value:"Index Join Scan",id:"index-join-scan",level:3},{value:"Index Organized Tables",id:"index-organized-tables",level:3},{value:"Bitmap Access Paths",id:"bitmap-access-paths",level:3},{value:"Join Methods",id:"join-methods",level:2},{value:"Nested Loop Join",id:"nested-loop-join",level:3},{value:"Sort Merge Join",id:"sort-merge-join",level:3},{value:"Hash Join",id:"hash-join",level:3},{value:"Cartesian Join",id:"cartesian-join",level:3},{value:"Index usage to get most performance",id:"index-usage-to-get-most-performance",level:2},{value:"Concatenation Operator",id:"concatenation-operator",level:3},{value:"Arithmetic Operators",id:"arithmetic-operators",level:3},{value:"LIKE conditions",id:"like-conditions",level:3},{value:"Function on Columns",id:"function-on-columns",level:3},{value:"Using NULL",id:"using-null",level:3},{value:"Using EXISTS instead of IN clause",id:"using-exists-instead-of-in-clause",level:3},{value:"TRUNCATE instead of DELETE",id:"truncate-instead-of-delete",level:3},{value:"Data Type Mismatch",id:"data-type-mismatch",level:3},{value:"ORDER BY clause",id:"order-by-clause",level:3},{value:"MIN &amp; MAX values",id:"min--max-values",level:3},{value:"UNION and UNION ALL",id:"union-and-union-all",level:3},{value:"Avoid using HAVING clause",id:"avoid-using-having-clause",level:3},{value:"Views",id:"views",level:3},{value:"Materialized Views",id:"materialized-views",level:3},{value:"Avoid commit too much or too less",id:"avoid-commit-too-much-or-too-less",level:3},{value:"Partition Pruning",id:"partition-pruning",level:3},{value:"BULK COLLECT",id:"bulk-collect",level:3},{value:"Join Order",id:"join-order",level:3},{value:"Multitable DML operations",id:"multitable-dml-operations",level:3},{value:"Temporary Tables",id:"temporary-tables",level:3},{value:"Combining SQL statements",id:"combining-sql-statements",level:3},{value:"WITH clause",id:"with-clause",level:3},{value:"Analytical Functions",id:"analytical-functions",level:3},{value:"Composite Indexes",id:"composite-indexes",level:2},{value:"Covering Indexes",id:"covering-indexes",level:2},{value:"Reverse key index",id:"reverse-key-index",level:2},{value:"Index-Organized tables",id:"index-organized-tables-1",level:2},{value:"Invisible Indexes",id:"invisible-indexes",level:2},{value:"Full-Text search indexes",id:"full-text-search-indexes",level:2},{value:"CONTEXT Type Index",id:"context-type-index",level:3},{value:"CTXCAT Type Index",id:"ctxcat-type-index",level:3},{value:"CTXRULE Type Index",id:"ctxrule-type-index",level:3}],u={toc:d};function m(e){let{components:t,...i}=e;return(0,s.kt)("wrapper",(0,a.Z)({},u,i,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h2",{id:"index"},"Index"),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(9015).Z,width:"423",height:"339"})),(0,s.kt)("h3",{id:"b-tree-indexes-balanced-tree"},"B-TREE Indexes (Balanced Tree)"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE INDEX index_name\nON table_name(column1[,column2,...])\n")),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(7059).Z,width:"933",height:"381"})),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"The index name should be meaningful and includes table alias and column name(s) where possible, along with the suffix ","_","I such as:")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"<table_name>_<column_name>_I\n")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"By default, the ",(0,s.kt)("inlineCode",{parentName:"li"},"CREATE INDEX")," statement creates a btree index."),(0,s.kt)("li",{parentName:"ul"},"When you create a new table with a primary key, Oracle automatically creates a new index for the primary key columns."),(0,s.kt)("li",{parentName:"ul"},"Unlike other database systems, Oracle does not automatically create an index for the foreign key columns.")),(0,s.kt)("h5",{id:"drop-index-if-exists"},"DROP INDEX IF EXISTS"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE index_count INTEGER;\nBEGIN\nSELECT COUNT(*) INTO index_count\n    FROM USER_INDEXES\n    WHERE INDEX_NAME = 'index_name';\n\nIF index_count > 0 THEN\n    EXECUTE IMMEDIATE 'DROP INDEX index_name';\nEND IF;\nEND;\n/\n")),(0,s.kt)("h5",{id:"unique-index"},"Unique Index"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE UNIQUE INDEX index_name ON\ntable_name(column1[,column2,...]);\n")),(0,s.kt)("h5",{id:"specify-name-for-index"},"Specify name for index"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"When you define a ",(0,s.kt)("inlineCode",{parentName:"li"},"PRIMARY KEY")," or a ",(0,s.kt)("inlineCode",{parentName:"li"},"UNIQUE")," constraint for a table, Oracle automatically creates a unique index on the primary key or unique key columns to enforce the uniqueness"),(0,s.kt)("li",{parentName:"ul"},"SYS_C007876 unique index was created automatically with the generated name.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE t2 (\n    pk2 INT PRIMARY KEY\n        USING INDEX (\n            CREATE INDEX t1_pk1_i ON t2 (pk2)\n    ),\n    c2 INT\n);\n")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Instead of generating the index name, Oracle just used the one that we provided during table creation.")),(0,s.kt)("h4",{id:"function-based-index"},"Function based Index"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE INDEX members_last_name_fi\nON members(UPPER(last_name));\n")),(0,s.kt)("h5",{id:"a-function-based-index-has-the-following-main-advantages"},"A function-based index has the following main advantages:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"A function-based index speeds up the query by giving the optimizer more chance to perform an index range scan instead of full index scan. Note that an index range scan has a fast response time when the ",(0,s.kt)("inlineCode",{parentName:"li"},"WHERE")," clause returns fewer than 15% of the rows of a large table."),(0,s.kt)("li",{parentName:"ul"},"A function-based index reduces computation for the database. If you have a query that consists of expression and use this query many times, the database has to calculate the expression each time you execute the query. To avoid these computations, you can create a function-based index that has the exact expression."),(0,s.kt)("li",{parentName:"ul"},"A function-based index helps you perform more flexible sorts. For example, the index expression can call ",(0,s.kt)("inlineCode",{parentName:"li"},"UPPER()")," and ",(0,s.kt)("inlineCode",{parentName:"li"},"LOWER()")," functions for case-insensitive sorts or ",(0,s.kt)("inlineCode",{parentName:"li"},"NLSSORT()")," function for linguistic-based sorts."),(0,s.kt)("li",{parentName:"ul"},"We can use any type of functions (built-in or user-defined)"),(0,s.kt)("li",{parentName:"ul"},"We can use multiple functions in a column or in multiple columns"),(0,s.kt)("li",{parentName:"ul"},"The restrictions:",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"The function needs to be deterministic. Random values or SYSDATE etc cannot be used."),(0,s.kt)("li",{parentName:"ul"},"Aggregate functions cannot be used"),(0,s.kt)("li",{parentName:"ul"},"Function needs to have a fixed-length data type")))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM employees;\nSELECT * FROM employees WHERE last_name = 'KING';\nSELECT * FROM employees WHERE UPPER(last_name) = 'KING';--Faster when created below function based index\n\nCREATE INDEX last_name_fix ON employees (UPPER(last_name));\nSELECT * FROM employees WHERE UPPER(substr(last_name,1,1)) = 'K';--Did not use the index as there is no function based index that uses substr here.\nDROP INDEX last_name_fix;\n\nCREATE INDEX last_name_fix ON employees (UPPER(substr(last_name,1,1)));\nSELECT * FROM employees WHERE UPPER(substr(last_name,1,1)) = 'K';--Used the index as this function based index is created in previous step.\nSELECT * FROM employees WHERE UPPER(substr(last_name,1,2)) = 'KI';--Did not use the index as there is no function based index that uses substr(1,2) here. For substr(1,1) only we created the index\nDROP INDEX last_name_fix;\n\nCREATE INDEX annual_salary_fix ON employees(salary*12-300); -- Function based index with arithmetic operations\nSELECT * FROM employees WHERE salary > 10000; -- Did not use index\nSELECT * FROM employees WHERE salary*12 > 10000; -- Did not use index\nSELECT * FROM employees WHERE salary*12-300 > 10000;-- Used the index as we created the index like that only\nSELECT * FROM employees WHERE salary*12-301 > 10000+1; -- Did not use index\nDROP INDEX annual_salary_fix;\n\n")),(0,s.kt)("h5",{id:"the-following-are-major-disadvantages-of-function-based-indexes"},"The following are major disadvantages of function-based indexes:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"The database has to compute the result of the index in every data modification which imposes a performance penalty for every write."),(0,s.kt)("li",{parentName:"ul"},"The function invoked involve in the index expression must be deterministic. It means that for the same input, the function always returns the same result."),(0,s.kt)("li",{parentName:"ul"},"The query optimizer can use a function-based index for cost-based optimization, not for rule-based optimization. Therefore, it does not use a function-based index until you analyze the index itself by invoking either ",(0,s.kt)("inlineCode",{parentName:"li"},"DBMS_STATS.GATHER_TABLE_STATS")," or ",(0,s.kt)("inlineCode",{parentName:"li"},"DBMS_STATS.GATHER_SCHEMA_STATS"),".")),(0,s.kt)("h3",{id:"bitmap-index"},"Bitmap Index"),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(441).Z,width:"918",height:"422"})),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"When a column has a few distinct values, we say that this column has low cardinality. Ex: Gender column")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Oracle has a special kind of index for these types of columns which is called a bitmap index.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"A bitmap index is a special kind of database index which uses bitmaps or bit array.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"In a bitmap index, Oracle stores a bitmap for each index key.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Each index key stores pointers to multiple rows.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"For gender column, It will create two separate bitmaps, one for each gender.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Oracle uses a mapping function to converts each bit in the bitmap to the corresponding rowid of the table.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Works faster than B-tree index for large number of rows in the result set")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Uses less disc space than the B-tree indexes."),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"It doesn't store values for each row."),(0,s.kt)("li",{parentName:"ul"},"It doesn't store all the rowids. Instead it stores the intervals and then converts when it needs."),(0,s.kt)("li",{parentName:"ul"},"Bitmaps are stored in compressed manner"))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Bitmap conversion needs more CPU usage then B-tree indexes")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Bitmap is efficient when query contains multiple conditions in the WHERE clause"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE customers_temp AS SELECT * FROM customers;\n-- B-Tree Index\nCREATE INDEX cust_city_ix ON customers_temp(cust_city);\nCREATE INDEX cust_name_ix ON customers_temp(cust_first_name,cust_last_name);\n\nSELECT * FROM customers_temp WHERE cust_city IN ('Aachen','Abingdon','Bolton','Santos');--Used index; Cost: 338\nSELECT * FROM customers_temp WHERE cust_city IN ('Aachen','Abingdon','Bolton','Santos','Barry','Westminster','Tilburg');--Did not use index. It used full table scan. If there are more than 6 values in IN clause, it tend to use full table scan; Cost: 406\nSELECT * FROM customers_temp WHERE cust_city IN ('Aachen','Abingdon','Bolton','Santos') AND cust_first_name = 'Abigail';--One more condition added. Converted b-tree index to bitmap index and reduced the cost; Cost: 7\nSELECT /*+ index(c cust_name_ix, cust_name_ix)*/* FROM customers_temp C WHERE cust_city IN ('Aachen','Abingdon','Bolton','Santos') AND cust_first_name = 'Abigail';--Cost is more than previous one;Cost: 9\n\nDROP INDEX cust_city_ix;\nDROP INDEX cust_name_ix;\n--Bitmap index\nCREATE BITMAP INDEX cust_city_bix ON customers_temp(cust_city);\nCREATE BITMAP INDEX cust_name_bix ON customers_temp(cust_first_name,cust_last_name);\n\nSELECT * FROM customers_temp WHERE cust_city IN ('Aachen','Abingdon','Bolton','Santos');--Cost 81\nSELECT * FROM customers_temp WHERE cust_city IN ('Aachen','Abingdon','Bolton','Santos','Barry','Westminster','Tilburg');--Cost: 133\nSELECT * FROM customers_temp WHERE cust_city IN ('Aachen','Abingdon','Bolton','Santos') AND cust_first_name = 'Abigail';--Cost: 6\n\nDROP TABLE customers_temp;\n"))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Bitmap index indexes NULL values also")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Can be used for parallel DML and parallel queries. No issue with that.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("inlineCode",{parentName:"p"},"Bitmap Join indexes")," are useful for multiple table reads. Useful when multiple tables are always read together and no clusters are created for that."),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"Bitmap Join Indexes need less space than materialized views.")),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE BITMAP INDEX sales_temp_bjx ON sales(P.prod_subcategory, C.cust_city)\nFROM sales S, products P, customers C\nWHERE S.prod_id = P.prod id\nAND S.cust id = C.cust id\nLOCAL; -- LOCAL because it is a partitioned table. Here, sales table is called fact table (main table). products and customers tables are called dimension tables\n")),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"Disadvantages of Bitmap Join indexes",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"Maintenance Cost is higher"),(0,s.kt)("li",{parentName:"ul"},"Only one table among the indexed tables can be updated concurrently by different transactions"),(0,s.kt)("li",{parentName:"ul"},"Parallel DML is only supported on the fact table"),(0,s.kt)("li",{parentName:"ul"},"The joined columns of dimension table needs to have a unique or primary key constraint"),(0,s.kt)("li",{parentName:"ul"},"If Dimension table has a multi-column primary key, each column of that PK must be in the join"),(0,s.kt)("li",{parentName:"ul"},"No table can be joined twice in the index"),(0,s.kt)("li",{parentName:"ul"},"Bitmap join indexes cannot be created on temporary tables")))))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"ALTER TABLE customers ENABLE VALIDATE CONSTRAINT customers_pk;\n\nALTER TABLE products ENABLE VALIDATE CONSTRAINT products_pk;\n\nSELECT AVG(S.quantity_sold) FROM sales S, products P, customers C\nWHERE S.prod_id = P.prod_id AND S.cust_id = C.cust_id AND P.prod_subcategory = 'CD-ROM' AND C.cust_city = 'Manchester'; -- This query increased performance after creating below bitmap join index\n\nCREATE BITMAP INDEX sales_temp_bjx ON sales(P.prod_subcategory, C.cust_city) FROM sales S, products P, customers C\nWHERE S.prod_id = P.prod_id AND S.cust_id = C.cust_id LOCAL;\n\nDROP INDEX sales_temp_bjx;\n\nSELECT DISTINCT C.cust_postal_code\nFROM sales S, products P, customers C\nWHERE S.prod_id = P.prod_id\nAND S.cust_id = C.cust_id\nAND C.cust_city = 'Manchester';-- This does not increased the performance much even after creating below bitmap index. Reason is we select columns from dimension table so it cannot find the ROWID of that from the index. Index stores only the ROWID of fact table.\n\nCREATE BITMAP INDEX sales_temp_bjx ON sales(C.cust_city)\nFROM sales S, products P, customers C\nWHERE S.prod_id = P.prod_id\nAND S.cust_id = C.cust_id\nLOCAL;\n\nSELECT DISTINCT S.channel_id\nFROM sales S, products P, customers C\nWHERE S.prod_id = P.prod_id\nAND S.cust_id = C.cust_id\nAND C.cust_city = 'Manchester';--Have better performance because the column is from fact table\n\nSELECT COUNT(*)\nFROM sales S, products P, customers C\nWHERE S.prod_id = P.prod_id\nAND S.cust_id = C.cust_id\nAND C.cust_city = 'Manchester';-- This is also faster as it did not need to read anything from the table.\n\nDROP INDEX sales_temp_bjx;\n\nALTER TABLE customers ENABLE NOVALIDATE CONSTRAINT customers_pk;\n\nALTER TABLE products ENABLE NOVALIDATE CONSTRAINT products_pk;\n")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Bitmap is usually easier to remove and re-create but maintaining is hard.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Not suitable for concurrent transactions modifying the indexes column. So it is not much suitable for OLTP transactions. It is useful for data warehousing (OLAP) where read is more than writing."),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"OLTP Use Cases: OLTP systems are found in practically every system that interacts with customers. Some examples of common transactional processing scenarios where OLTP systems are used are ATM and Online Banking, Payment Processing, Online Booking, Recordkeeping."),(0,s.kt)("li",{parentName:"ul"},"OLAP Use Cases: Every branch of business that benefits from data analysis have an OLAP system. Analytic processing is frequently used in Trend Analysis, Customer Behavior, etc.")))),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:null},"Parameters"),(0,s.kt)("th",{parentName:"tr",align:null},"OLTP (online transactional processing)"),(0,s.kt)("th",{parentName:"tr",align:null},"OLAP(Online analytical processing)"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"Process"),(0,s.kt)("td",{parentName:"tr",align:null},"OLTP is an online transactional system for database modification and is characterized by a large number of small online transactions."),(0,s.kt)("td",{parentName:"tr",align:null},"It is a process of online analysis and data retrieving and is characterized by working with large amount of data")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"Method and Functionality"),(0,s.kt)("td",{parentName:"tr",align:null},"It uses traditional DBMS and is an online databse modifying system"),(0,s.kt)("td",{parentName:"tr",align:null},"OLAP uses data warehouse for online database query management")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"Query Types"),(0,s.kt)("td",{parentName:"tr",align:null},"Insert, Update, and Delete information from databases"),(0,s.kt)("td",{parentName:"tr",align:null},"Select Operations")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"Table type"),(0,s.kt)("td",{parentName:"tr",align:null},"Normalized"),(0,s.kt)("td",{parentName:"tr",align:null},"Not normalized")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"Data Sources"),(0,s.kt)("td",{parentName:"tr",align:null},"OLTP and its transactions are the data sources"),(0,s.kt)("td",{parentName:"tr",align:null},"The different OLTP databases are the data sources for OLAP")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"Data Integrity Concerns"),(0,s.kt)("td",{parentName:"tr",align:null},"It is mandatory for OLTP databases to maintain integrity constraint"),(0,s.kt)("td",{parentName:"tr",align:null},"Data integrity is not an issue as OLAP databases do not get frequently modified")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"Read/ Write Operations"),(0,s.kt)("td",{parentName:"tr",align:null},"Allows Read and Write operations"),(0,s.kt)("td",{parentName:"tr",align:null},"Allows Read operations and rarely allows write operations")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"Response Time"),(0,s.kt)("td",{parentName:"tr",align:null},"Milliseconds"),(0,s.kt)("td",{parentName:"tr",align:null},"Seconds to minutes")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"Use-Cases"),(0,s.kt)("td",{parentName:"tr",align:null},"Helps to control and run fundamental business tasks"),(0,s.kt)("td",{parentName:"tr",align:null},"Planning, problem-solving, and decision support")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"Query Complexity"),(0,s.kt)("td",{parentName:"tr",align:null},"Simple and standardized"),(0,s.kt)("td",{parentName:"tr",align:null},"Complex queries with aggregations")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"Data Quality"),(0,s.kt)("td",{parentName:"tr",align:null},"Database is always detailed and organized."),(0,s.kt)("td",{parentName:"tr",align:null},"Data might not always be organized")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"Back-up"),(0,s.kt)("td",{parentName:"tr",align:null},"Complete backup of the data combined with incremental backups"),(0,s.kt)("td",{parentName:"tr",align:null},"OLAP only need a backup from time to time. Backup is not important compared to OLTP")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"Database Design"),(0,s.kt)("td",{parentName:"tr",align:null},"Database Design is application oriented, i.e., it changes with industry like Retail, Airline, Banking, etc."),(0,s.kt)("td",{parentName:"tr",align:null},"DB design is subject oriented, i.e., it changes with subjects like sales, marketing, purchasing, etc.")))),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"You need to select Global or Local Index partitioning carefully. When you create partition table with indexes, we can create ",(0,s.kt)("inlineCode",{parentName:"li"},"Global Index")," or ",(0,s.kt)("inlineCode",{parentName:"li"},"Local Index"),".",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"Global indexes have 1 to many relationship on partitions. ie; an index indexes multiple partitions. In this case, you can perform range and hash scans on multiple partitions. So performing parallel execution increase the performance."),(0,s.kt)("li",{parentName:"ul"},"Local index have 1 to 1 relation with partition. ie; Index indexes partition individually. In this case, it cannot perform range scan on multiple partitions with one index. This is easier to maintain. If you are selecting from single partition, local index would be better.")))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE BITMAP INDEX index_name\nON table_name(column1[,column2,...]);\n")),(0,s.kt)("h4",{id:"bitmap-operations"},"Bitmap Operations"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Bitmap Conversion To ROWID")," - Converts the bitmaps to the corresponding ROWIDs. Bitmap doesnot stores all ROWIDs. It stores bitmap and the ROWID intervals of that bitmap. First bit shows first ROWID and last bit shows last ROWID. For other ROWIDs, it need to calculate the ROWIDs"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Bitmap Conversion From ROWID")," - Generates a bitmap index from b-tree. This happens if the bitmap comparision operators are faster than b-tree indexes."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Bitmap Conversion Count")," - Calculates the count by using the index. Here bitmap index can count NULL values as well as it stores NULL values also. If there is a NULLABLE column and we want to find the count of rows, b-tree index uses full table scan. For bitmap index it does not need that."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Bitmap Index Single Value")," - Gets a single value by using the index"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Bitmap Range Scan")," - Performs a range scan over the bitmap index"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Bitmap Full Scan")," - Reads the whole bitmap to return the result"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Bitmap Merge Scan")," - Merges multiple bitmaps ( result of a range scan ) into one bitmap"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Bitmap AND")," - Performs an AND operation over the bits of two bitmaps"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Bitmap OR")," - Performs an OR operation over the bits of two bitmaps"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Bitmap Minus")," - Performs an AND operation between a bitmap and the negated version of another bitmap"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Bitmap Key Iteration")," - Takes each row from a table row source, finds the corresponding bitmaps and merges them")),(0,s.kt)("h4",{id:"when-to-use-oracle-bitmap-indexes"},"When to use Oracle bitmap indexes"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"You should use the bitmap index for the columns that have low cardinality. To find the cardinality of a column, you can use the following query:")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT column, COUNT(*)\nFROM table_name\nGROUP BY column;\n")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"A good practice is any column which has less than 100 distinct values can consider for bitmap index."),(0,s.kt)("li",{parentName:"ul"},"Maintaining a bitmap index takes a lot of resources, therefore, bitmap indexes are only good for the read-only tables or tables that have infrequently updates."),(0,s.kt)("li",{parentName:"ul"},"Therefore, you often find bitmap indexes are extensively used in the data warehouse environment."),(0,s.kt)("li",{parentName:"ul"},"Notice that using a bitmap index for a table that has many single row update, especially concurrent single row update will cause a deadlock.")),(0,s.kt)("p",null,"Ex:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE bitmap_index_demo(\n    id INT GENERATED BY DEFAULT AS IDENTITY,\n    active NUMBER NOT NULL,\n    PRIMARY KEY(id)\n);\n\nCREATE BITMAP INDEX bitmap_index_demo_active_i\nON bitmap_index_demo(active);\n\n")),(0,s.kt)("p",null,"Open two sessions and repeatedly execute one of the following statements in each session:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"INSERT INTO bitmap_index_demo(active)\nVALUES(1);\n\nINSERT INTO bitmap_index_demo(active)\nVALUES(0);\n")),(0,s.kt)("p",null,"The following error will occur:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"ORA-00060: deadlock detected while waiting for resource\n")),(0,s.kt)("h2",{id:"to-build-an-execution-plan-the-optimizer-checks"},"To build an execution plan the optimizer checks:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Access paths. Ex: Full table scan, Index scan"),(0,s.kt)("li",{parentName:"ul"},"Join methods: These are the ways to join the row sources to build a new row source. Ex: Nested Loop Join, Sort Merge Join"),(0,s.kt)("li",{parentName:"ul"},"Join orders: These are the algorithms of optimizer on how to join these row sources logically")),(0,s.kt)("h2",{id:"table-access-paths"},"Table Access Paths"),(0,s.kt)("h3",{id:"table-access-full-full-table-scan"},"Table Access Full (Full Table Scan)"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Since one block has data from single table, once the server goes to that block (I/O operation), reading the whole block will be faster when you need to return big portion of the table"),(0,s.kt)("li",{parentName:"ul"},"If DB_FILE_MULTIBLOCK_READ_COUNT = 1, then it reads only 1 block at a time"),(0,s.kt)("li",{parentName:"ul"},"If it is DB_FILE_MULTIBLOCK_READ_COUNT = 4, it reads 4 blocks at a time and it speed up the reading process."),(0,s.kt)("li",{parentName:"ul"},"If we use index here, instead of full table scan, oracle need to jump to different different blocks according to the row id stored in indexes.")),(0,s.kt)("h4",{id:"reasons-for-full-table-scan"},"Reasons for Full Table Scan"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"If there is not suitable index"),(0,s.kt)("li",{parentName:"ul"},"If the selectivity is low"),(0,s.kt)("li",{parentName:"ul"},"If the table is very small"),(0,s.kt)("li",{parentName:"ul"},"If full table scan hint is used")),(0,s.kt)("h3",{id:"table-access-by-rowid"},"Table Access by ROWID"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Access by ROWID occurs when:",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"ROWID is used in WHERE clause directly"),(0,s.kt)("li",{parentName:"ul"},"By and index scan operation")))),(0,s.kt)("p",null,"Note: If we are selecting only the columns which are existing in index, that data will be taken directly from the index and not from table. If we take some other columns also - which are not part of index, it will convert index to ROWID and using ROWID, it will fetch from table."),(0,s.kt)("h3",{id:"sample-table-scan"},"Sample Table Scan"),(0,s.kt)("h2",{id:"index-rebuild"},"Index Rebuild"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Balanced Tree indexes are always balanced. All leaf blocks stays at the same length. The number of blocks required to go from root block to leaf block is called ",(0,s.kt)("inlineCode",{parentName:"li"},"index height"),"."),(0,s.kt)("li",{parentName:"ul"},"While we insert or update some rows, if the leaf block does not have space to store the new value, that block is split into two blocks. And when some rows are removed, there will be unnessasary blocks, branches and leafs. This will decrease the performance."),(0,s.kt)("li",{parentName:"ul"},"To solve this problem use below methods")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"ALTER INDEX index_name REBUILD; -- Cleaner\n\nALTER INDEX index_name COALESCE;--Faster\n")),(0,s.kt)("h2",{id:"index-compression"},"Index Compression"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"If the selectivity of the btree index is low, compressing the index may work faster."),(0,s.kt)("li",{parentName:"ul"},"If there are lots of redundant data in the index, it might be useful to compress it (Will decrease the size and may increase the performance)"),(0,s.kt)("li",{parentName:"ul"},"Like table compression, there is a token table which stores the redundant keys and a row table that includes the distinct rows"),(0,s.kt)("li",{parentName:"ul"},"Can be applied to unique and non-unique indexes"),(0,s.kt)("li",{parentName:"ul"},"It will work better for non-unique indexes."),(0,s.kt)("li",{parentName:"ul"},"It eliminates the duplicate keys"),(0,s.kt)("li",{parentName:"ul"},"Composite indexes can be compressed by the first N keys. For example, we can compress the first two columns of the index or we can compress all the columns together; but we cannot compress a specific column of the index which is not the first column."),(0,s.kt)("li",{parentName:"ul"},"Sometime this compression may not decrease the size or increase the performance. It depends on the number of distict values in your index columns."),(0,s.kt)("li",{parentName:"ul"},"From Oracle 12C, advanced key compression is introduced.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE INDEX ix ON temp(a, b,c) COMPRESS [N]; -- N is the compression level. If it is NULL, then it will compress all the columns\nCREATE INDEX ix ON temp(a, b,c) COMPRESS ADVANCED HIGH LOW; -- From 12C.\n")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Things to know about index compression:",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"Column order is important. You need to write the least selective column first. ie; the column, which has the highest number of duplicate values, should be the first column of the index, and the rest also should be written in this logic from highest duplicate to the lowest."),(0,s.kt)("li",{parentName:"ul"},"Bitmap indexes cannot be compressed. It can only be applied to B-Tree indexes."),(0,s.kt)("li",{parentName:"ul"},"Partitioned indexes cannot be compressed before 11g version. We cannot compress a specific partition directly, but we can do that by creating an index as compressed and then disable the index key compression for the specific partitions."),(0,s.kt)("li",{parentName:"ul"},"Can be alternative to bitmap indexes in some cases"),(0,s.kt)("li",{parentName:"ul"},"Indexes are created as non-compressed by default")))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE sales_temp AS SELECT * FROM sales;\n\nCREATE INDEX sales_idx ON sales_temp(prod_id,cust_id,time_id,amount_sold);\n\nSELECT BYTES/(1024*1024) mb FROM user_segments WHERE  segment_name = 'SALES_IDX';\n/*Index size*/\n--Before Compression: 32MB\n--Compress 1st column: 28MB\n--Compress first 2 columns: 28MB\n--Compress first 3 columns: 33MB\n--Compress first all columns: 36MB\n--Compress LOW: 28MB\n--Compress HIGH: 15MB\n\nSELECT index_name, index_type, leaf_blocks, compression FROM user_indexes\nWHERE index_name = 'SALES_IDX';\n\nSELECT prod_id,cust_id,time_id FROM sales_temp\nWHERE prod_id = 13;\n/*Cost*/\n--Before Compression: 57\n--Compress 1st column: 51\n--Compress first 2 columns: 51\n--Compress first 3 columns: 59\n--Compress first all columns: 64\n--Compress LOW: 50\n--Compress HIGH: 2\n\nALTER INDEX sales_idx REBUILD COMPRESS 1;--Compress 1st column\n\nALTER INDEX sales_idx REBUILD COMPRESS 2;--Compress first 2 columns; Concatenation of 2 columns to find the duplicates\n\nALTER INDEX sales_idx REBUILD COMPRESS 3;--Compress first 3 columns; Concatenation of 3 columns to find the duplicates\n\nALTER INDEX sales_idx REBUILD COMPRESS;--Compress all columns; Concatenation of all columns to find the duplicates\n\nALTER INDEX sales_idx REBUILD COMPRESS ADVANCED LOW;\n\nALTER INDEX sales_idx REBUILD COMPRESS ADVANCED HIGH; -- More CPU and more maintenance cost is there than ADVANCED LOW. It may decrease the performance of the table when performing DML operations. More suitable for datawarehousing or for tables does not have much DML operations.\n\nDROP INDEX sales_idx;\nCREATE BITMAP INDEX sales_idx ON sales_temp(prod_id,cust_id,time_id,amount_sold); --More cost than the compressed B-Tree index\n\nDROP INDEX sales_idx;\nCREATE BITMAP INDEX sales_idx ON sales_temp(prod_id,cust_id,time_id,amount_sold) COMPRESS;--Compression doesnot work on bitmap index\n\nDROP TABLE sales_temp;\n")),(0,s.kt)("h2",{id:"index-access-paths"},"Index Access Paths"),(0,s.kt)("h3",{id:"index-unique-scan"},"Index Unique Scan"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"A single row will be fetched."),(0,s.kt)("li",{parentName:"ul"},"This scan will be performed on primary key or unique index column"),(0,s.kt)("li",{parentName:"ul"},"If the column is unique and not using unique index will make the optimizer to use range scan."),(0,s.kt)("li",{parentName:"ul"},"Note: It may show as RANGE SCAN on explain plan but it may be doing unique scan. So check for range in explain plan to confirm it is range scan or unique scan.")),(0,s.kt)("h3",{id:"index-range-scan"},"Index Range Scan"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Can be applied to b-tree and bitmap indexes"),(0,s.kt)("li",{parentName:"ul"},"Can be applied to unique, non-unique, function-based indexes"),(0,s.kt)("li",{parentName:"ul"},"Normally data is stored in ascending order in the indexes. So, it will stop searching for other branches when it finds the last node."),(0,s.kt)("li",{parentName:"ul"},"If the query includes ORDER BY or GROUP BY clauses with indexing columns, range scan no need to do any sort as it is already sorted. Exceptions: if there are NULL values in column, it will do the sorting.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"-- Order by with the indexed column -  sort is processed\nSELECT * FROM employees where employee_id > 190 order by email;\n\n-- Order by with the indexed column - no sort is processed\nSELECT * FROM employees where employee_id > 190 order by employee_id;\n")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"If ORDER BY has DESC keyword, it will read the data in descending order. No need to sort here also.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"-- Index range scan descending\nSELECT * FROM employees where department_id > 80 order by department_id desc;\n")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"If you are using wildcard before the text or wilcard on both sides, it will not use range scan. If you using wildcard after the text, it will use range scan.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"-- Index range scan with wildcard\nSELECT * FROM PRODUCTS WHERE PROD_SUBCATEGORY LIKE 'Accessories%';\nSELECT * FROM PRODUCTS WHERE PROD_SUBCATEGORY LIKE '%Accessories';\nSELECT * FROM PRODUCTS WHERE PROD_SUBCATEGORY LIKE '%Accessories%';\n")),(0,s.kt)("h3",{id:"index-full-scan"},"Index Full Scan"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Optimizer uses index full scan when:",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"All the rows of the table are indexed"),(0,s.kt)("li",{parentName:"ul"},"If there is a ORDER BY or GROUP BY operation with the indexed columns,as index is already sorted it need not to sort it again."),(0,s.kt)("li",{parentName:"ul"},"For ORDER BY, the order of the sorting should match the order the index is created. Ex: Index created with FIRST_NAME, LAST_NAME and query used order by LAST_NAME, FIRST_NAME, it will not use the index."),(0,s.kt)("li",{parentName:"ul"},"For GROUP BY this order is not important."),(0,s.kt)("li",{parentName:"ul"},"Query requires a sort-merge join")))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"/* Index usage with order by */\nSELECT * FROM departments ORDER BY department_id;\n\n/* Index usage with order by, one column of an index - causes index full scan*/\nSELECT last_name,first_name FROM employees ORDER BY last_name;\n\n/* Index usage with order by, one column of an index - causes unnecessary sort operation*/\nSELECT last_name,first_name FROM employees ORDER BY first_name;\n\n/* Index usage with order by, but with wrong order - causes unnecessary sort operation */\nSELECT last_name,first_name FROM employees ORDER BY first_name,last_name;\n\n/* Index usage with order by, with right order of the index - there is no unncessary sort */\nSELECT last_name,first_name FROM employees ORDER BY last_name,first_name;\n\n/* Index usage with order by, wit unindexed column - there is no unncessary sort */\nSELECT last_name,first_name FROM employees ORDER BY last_name,salary;\n\n/* Index usage order by - when use * , it performed full table scan */\nSELECT * FROM employees ORDER BY last_name,first_name;\n\n/* Index usage with group by - using a column with no index leads a full table scan */\nSELECT salary,count(*) FROM employees e\nWHERE salary IS NOT NULL\nGROUP BY salary;\n\n/* Index usage with group by - using indexed columns may lead to a index full scan */\nSELECT department_id,count(*) FROM employees e\nWHERE department_id IS NOT NULL\nGROUP BY department_id;\n\n/* Index usage with group by - using more columns than ONE index has may prevent index full scan */\nSELECT department_id,manager_id,count(*) FROM employees e\nWHERE department_id IS NOT NULL\nGROUP BY department_id, manager_id;\n\n/* Index usage with merge join */\nSELECT e.employee_id, e.last_name, e.first_name, e.department_id,\n       d.department_name\nFROM   employees e, departments d\nWHERE  e.department_id = d.department_id;\n")),(0,s.kt)("h3",{id:"index-fast-full-scan"},"Index Fast Full Scan"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"If the query requires only the columns existing in the index, it uses IFF scan"),(0,s.kt)("table",{parentName:"li"},(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:null},"Index Full Scan"),(0,s.kt)("th",{parentName:"tr",align:null},"Index Fast Full Scan"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"IF scan may read from table too"),(0,s.kt)("td",{parentName:"tr",align:null},"IFF scan always reads only from the index")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"Reads blocks one by one sequentially"),(0,s.kt)("td",{parentName:"tr",align:null},"Reads multiple blocks simultaneously in unordered manner")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"Faster than IFF is sorting is there"),(0,s.kt)("td",{parentName:"tr",align:null},"Faster than IF Scan if sorting is not there")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"Can be used to eliminate extra sorting"),(0,s.kt)("td",{parentName:"tr",align:null},"As it is read in unordered manner, it cannot skip sorting if needed")))))),(0,s.kt)("h3",{id:"index-skip-scan"},"Index Skip Scan"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"If you dont use the indexed columns on the where clause, the optimizer will not use the indexes"),(0,s.kt)("li",{parentName:"ul"},"If any column of a composite index is used as an access predicate, the optimizer will consider index skip scan"),(0,s.kt)("li",{parentName:"ul"},"If you use the first column in the composite index as access predicate, it may perform index full scan or index range scan."),(0,s.kt)("li",{parentName:"ul"},"If you use any other column other than the first one, it may use IS scan"),(0,s.kt)("li",{parentName:"ul"},"Below screenshot has index of GENDER and AGE column")),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(1222).Z,width:"1897",height:"823"})),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"/*Index skip scan usage with equality operator*/\nSELECT * FROM employees WHERE first_name = 'Alex';\n\n/* Index range scan occurs if we use the first column of the index */\nSELECT * FROM employees WHERE last_name = 'King';\n\n/* Using index skip scan with adding a new index */\nSELECT * FROM employees WHERE salary BETWEEN 6000 AND 7000;\nCREATE INDEX dept_sal_ix ON employees (department_id,salary);\nDROP INDEX dept_sal_ix;\n\n/* Using index skip scan with adding a new index\n   This time the cost increases significantly */\nALTER INDEX customers_yob_bix invisible; -- Disable the index\nSELECT * FROM customers WHERE cust_year_of_birth BETWEEN 1989 AND 1990;\nCREATE INDEX customers_gen_dob_ix ON customers (cust_gender,cust_year_of_birth);\nDROP INDEX customers_gen_dob_ix;\nALTER INDEX customers_yob_bix visible;-- Enable the index\n")),(0,s.kt)("h3",{id:"index-join-scan"},"Index Join Scan"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"If multiple indexes stores columns of a query, optimizer will join the indexes and read data from them. This is called Index join scan or index hash join scan."),(0,s.kt)("li",{parentName:"ul"},"All the columns in the select clause should be there in the combination of index to perform this"),(0,s.kt)("li",{parentName:"ul"},"There is no join limit. More than two indexes can be joined. Mostly optimizer won't join more than two as its cost may increase than other execution plans"),(0,s.kt)("li",{parentName:"ul"},"If you put ROWID in the select clause, it will not perform index join scan as it is not there in the column combination."),(0,s.kt)("li",{parentName:"ul"},"In index join scan, we can see a temporary view is created to join these indexes")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"/* Index join scan with two indexes */\nSELECT employee_id,email FROM employees;\n\n/* Index join scan with two indexes, but with range scan included*/\nSELECT last_name,email FROM employees WHERE last_name LIKE 'B%';\n\n/* Index join scan is not performed when we add rowid to the select clause */\nSELECT rowid,employee_id,email FROM employees;\n")),(0,s.kt)("h3",{id:"index-organized-tables"},"Index Organized Tables"),(0,s.kt)("h3",{id:"bitmap-access-paths"},"Bitmap Access Paths"),(0,s.kt)("h2",{id:"join-methods"},"Join Methods"),(0,s.kt)("h3",{id:"nested-loop-join"},"Nested Loop Join"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Nested loop join is efficient when joining row sources are small or bigger one has an index"),(0,s.kt)("li",{parentName:"ul"},"Nested loop is efficient if you need to show some of the rows immediately"),(0,s.kt)("li",{parentName:"ul"},"Hash join needs to create Hash table, Sort merge need to sort. So it will take time to return even if there is some rows. Nested loop returns first matching row immediately."),(0,s.kt)("li",{parentName:"ul"},"In this join type, the driving table (External table/ Outer table) is read once and joining table(Inner table) is read for every row of driving table"),(0,s.kt)("li",{parentName:"ul"},"Table is the general name, but it is actually a row source"),(0,s.kt)("li",{parentName:"ul"},"With USE_NL(table1 table2) hint, table1 doesn't mean that it would be a driving table and table2 would be joining table. For specifying driving table, we need to use LEADING hint also."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Oracle Prefetching")," : It performs index range scan and prefetch all the row IDs from index. If that index does not have all the required columns, it fetch from table by reading multiple blocks for each row ID instead of reading one block for each row ID")),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(504).Z,width:"1258",height:"813"})),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"/* Nested loop join example */\nSELECT * FROM employees e JOIN departments d\nON d.department_id = e.department_id\nWHERE d.department_id = 60;\n\n/* Even if we change the join order and on clause order, the plan did not change */\nSELECT * FROM departments d JOIN employees e\nON e.department_id = d.department_id\nWHERE d.department_id = 60;\n\n/* We can use leading hint to change the driving table */\nSELECT /*+ leading(e) */ * FROM employees e JOIN departments d\nON d.department_id = e.department_id\nWHERE d.department_id = 60;\n\n/* Does not use nested loop without hint */\nSELECT * FROM employees e JOIN departments d\nON d.department_id = e.department_id;\n\n/* Using nested loop hint */\nSELECT /*+ use_nl(d e) */ * FROM employees e JOIN departments d\nON d.department_id = e.department_id;\n\n/* Nested loop prefetching and double nested loops example */\nSELECT e.employee_id,e.last_name,d.department_id,d.department_name\nFROM employees e JOIN departments d\nON d.department_id = e.department_id\nWHERE d.department_name LIKE 'A%';\n")),(0,s.kt)("h3",{id:"sort-merge-join"},"Sort Merge Join"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Sort merge join is better than nested loop if table is big and (or) one side is sorted."),(0,s.kt)("li",{parentName:"ul"},"It sorts both row sources"),(0,s.kt)("li",{parentName:"ul"},"If the sort exceeds the sort area in PGA, it will write the sorted data into the disc and this increases the cost."),(0,s.kt)("li",{parentName:"ul"},"To reduce this sorting operation cost, optimizer will choose Index Full Scan or Index Range Scan if available; since data in indexes are already sorted."),(0,s.kt)("li",{parentName:"ul"},"Sort is done on joining keys. Ex: If joined by using DEPT_ID then need to sort using DEPT_ID"),(0,s.kt)("li",{parentName:"ul"},"In sort merge, there is no driving table or inner table as they are merged"),(0,s.kt)("li",{parentName:"ul"},"If row source is already sorted, then there will be no sort key in the execution plan"),(0,s.kt)("li",{parentName:"ul"},"Sort merge join is efficient when the join condition is not an equijoin\n",(0,s.kt)("img",{src:n(8565).Z,width:"395",height:"302"}))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"/* Sort Merge Join example */\nSELECT * FROM employees e JOIN departments d\nON d.department_id = e.department_id\nWHERE e.last_name like 'K%';\n\n/* Force it to use Nested Loop Join */\nSELECT /*+ use_nl(e d) */* FROM employees e JOIN departments d\nON d.department_id = e.department_id\nWHERE e.last_name like 'K%';\n\n/* Another Sort Merge Join example */\nSELECT * FROM employees e JOIN departments d\nON d.department_id = e.department_id\nWHERE d.manager_id > 110;\n\n/* Equality Operator prevented Sort Merge Join */\nSELECT * FROM employees e JOIN departments d\nON d.department_id = e.department_id\nWHERE d.manager_id = 110;\n\n/* Using Sort Merge Join Hint*/\nSELECT /*+ use_merge(e d) */* FROM employees e JOIN departments d\nON d.department_id = e.department_id\nWHERE d.manager_id = 110;\n")),(0,s.kt)("h3",{id:"hash-join"},"Hash Join"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Hash join is better than sort merge join for most cases if both sides are not sorted already"),(0,s.kt)("li",{parentName:"ul"},"It creates hash table with the hash function by using the smaller table and joins this hash table with other row sources"),(0,s.kt)("li",{parentName:"ul"},"The keys of the second row source is hashed and checked against the hash table. So it will create hash value for each row one by one for the second row source and it will be checked against the hash table."),(0,s.kt)("li",{parentName:"ul"},"If the new hash table not fitting into the memory, optimizer will write the rest of hash table into the disk for some time."),(0,s.kt)("li",{parentName:"ul"},"Full table scan is performed to the table that will be hashed"),(0,s.kt)("li",{parentName:"ul"},"Hash join is performed only when an equijoin is used\n",(0,s.kt)("img",{src:n(9680).Z,width:"640",height:"369"}))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"GRANT select_catalog_role TO hr;\nGRANT SELECT ANY DICTIONARY TO hr;\n\nSELECT * FROM employees e, departments d\nWHERE d.department_id = e.department_id\nAND d.manager_id = 110;\n\nSELECT /*+ use_hash(d e) */ * FROM employees e, departments d\nWHERE d.department_id = e.department_id\nAND d.manager_id = 110;\n")),(0,s.kt)("h3",{id:"cartesian-join"},"Cartesian Join"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Cartesian product is the most costy one. It joins all the rows of one side with all the rows of the other side"),(0,s.kt)("li",{parentName:"ul"},"It is mostly done by mistake by forgetting to write the join condition"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"BUFFER(SORT)"),": It uses SORT area to store data of one table so it can read the data faster than reading it from disk. It has not sorted. It is just using that SORT memory area.\n",(0,s.kt)("img",{src:n(285).Z,width:"1244",height:"390"}))),(0,s.kt)("h2",{id:"index-usage-to-get-most-performance"},"Index usage to get most performance"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"If the selectivity of the predicate is high, using indexes may increase the performance."),(0,s.kt)("li",{parentName:"ul"},"Use indexed columns in your queries clearly"),(0,s.kt)("li",{parentName:"ul"},"If possible, select only the indexed columns")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT cust_first_name, cust_last_name, cust_year_of_birth FROM customers\nWHERE cust_id = 975; -- It will use index\n\nSELECT cust_first_name, cust_last_name, cust_year_of_birth FROM customers\nWHERE cust_id <> 975;-- It will not use index. Not selective enough\n\nSELECT cust_first_name, cust_last_name, cust_year_of_birth FROM customers\nWHERE cust_id < 5000;-- It will not use index. More number of rows selected. So it used full table scan\n\nSELECT cust_first_name, cust_last_name FROM customers\nWHERE cust_id BETWEEN 100 AND 130; -- Uses index range scan\n\nSELECT E.employee_id, E.last_name, E.job_id, E.manager_id, D.department_name,D.department_id, C.country_name\nFROM employees E, departments D, locations L, countries C\nWHERE E.department_id = D.department_id\nAND D.location_id = L.location_id\nAND L.country_id = C.country_id\nAND E.employee_id BETWEEN 120 AND 199;\n\nSELECT E.employee_id, E.last_name, E.job_id,E.manager_id, D.department_name,D.department_id, C.country_name\nFROM employees E, departments D, locations L, countries C\nWHERE E.department_id = D.department_id\nAND D.location_id = L.location_id\nAND L.country_id = C.country_id\nAND E.employee_id BETWEEN 120 AND 199\nAND E.department_id IN (50,80); -- Giving an indexed column in WHERE clause will increase the performance. So give as much of filters we can\n")),(0,s.kt)("h3",{id:"concatenation-operator"},"Concatenation Operator"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT first_name, last_name, department_name\nFROM employees\nWHERE first_name| |last_name = 'StevenKING';\n--This will not use index as there is no index with concatenated values. So it will decrease the performance\n\nSELECT first_name, last_name, department name FROM employees\nWHERE first_name = 'Steven'\nAND last_name = 'KING'; -- Use like this instead\n")),(0,s.kt)("h3",{id:"arithmetic-operators"},"Arithmetic Operators"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT prod_id,cust_id,time_id FROM sales WHERE time_id+10 = '20-JAN-98'; -- This will not use the index because time_id+10 is not indexed\n\nSELECT prod_id,cust_id,time_id FROM sales WHERE time_id = '10-JAN-98';--Instead of that, we can do arithmetic operations on other side of the operator. So the optimizer can see the indexed column clearly.\n\nSELECT prod_id, cust_id, time_id FROM sales\nWHERE time_id = TO_DATE('20-JAN-98', 'DD-MON-RR')-10;-- Also correct\n")),(0,s.kt)("h3",{id:"like-conditions"},"LIKE conditions"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"select employee_id, first_name, last_name, salary from employees\nwhere last_name like '%on';--Need to use wildcard operator after the character. This query will not use the index\n\nselect employee_id, first_name, last_name, salary from employees\nwhere last_name like '%on%';--This also does not use the index\n\nselect employee_id, first_name, last_name, salary from employees\nwhere last_name like 'Ba%';--This will use the index\n\ncreate index last_name_reverse_index on employees(REVERSE(last_name)); -- One thing you can do to search with wildcard at the begining is to create a reverse index\n\nselect employee_id, first_name, last_name, reverse(last_name), salary\nfrom employees\nwhere reverse(last_name) like 'rahh%';--So to use the reversed index, You have to reverse your column value and can use wildcard at the end. (This will ultimately help us to use wildcard at the begining of the original text ie; %hhar)\n\ndrop index last_name_reverse_index;\n")),(0,s.kt)("h3",{id:"function-on-columns"},"Function on Columns"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"create index emp_date_temp_idx on employees (hire_date) compute statistics;\n\nselect employee_id, first_name, last_name\nfrom employees where trunc(hire_date,'YEAR') = '01-JAN-2002'; -- This will not use the index as there is no index with TRUNC(HIRE_DATE,'YEAR')\n\nselect employee_id, first_name, last_name\nfrom employees where hire_date between '01-JAN-2002' and '31-DEC-2002';--This will use the index\n\ndrop index emp_date_temp_idx;\n\nselect prod_id,prod_category,prod_subcategory from products\nwhere substr(prod_subcategory,1,2) = 'Po'; -- This will not use index as there is no index with SUBSTR\n\nselect prod_id,prod_category,prod_subcategory from products\nwhere prod_subcategory like 'Po%';--This will do the same thing as above query but uses the index. Because there is no function involved in query and index\n")),(0,s.kt)("h3",{id:"using-null"},"Using NULL"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"B-Tree indexes do not index the null values and this sometimes may suppress the index usages in our queries."),(0,s.kt)("li",{parentName:"ul"},"Ways to handle NULL value based performance loss :",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"Use IS NOT NULL condition in your where clause if you don't need to have the NULL values in the resultset. So this will use the index"),(0,s.kt)("li",{parentName:"ul"},"Add NOT NULL constraint to your columns and insert a specific value for the NULL values. Ex: Instead of inserting NULL, insert 0 or 'X'"),(0,s.kt)("li",{parentName:"ul"},"If reasonable, create a BITMAP index instead of a B-TREE index (BITMAP indexes store the NULL values). But use bitmap only if the cardinality is less")))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE employees_temp AS SELECT * FROM employees;\n\nCREATE INDEX comm_pct_idx ON employees_temp(commission_pct) COMPUTE STATISTICS;\n\nSELECT * FROM employees_temp WHERE commission_pct <> 1; --commission_pct column has NULL values. So it donot use the index\n\nSELECT * FROM employees_temp WHERE commission_pct <> 1 AND commission_pct IS NOT NULL;--Here we excluded NULL values. So it will use the index\n\nSELECT employee_id,commission_pct FROM employees_temp WHERE commission_pct IS NULL;--This will not use the index\n\nSELECT /*+ index(employees_temp comm_pct_idx)*/employee_id,commission_pct\nFROM employees_temp WHERE commission_pct IS NULL; --Optimizer donot use the index even if you put hints as there is no value for NULL in index\n\nUPDATE employees_temp SET commission_pct = 0 WHERE commission_pct IS NULL;-- Update NULL with some other value\nCOMMIT;\n\nSELECT employee_id,commission_pct FROM employees_temp WHERE commission_pct = 0; -- Here, it will use the index\n\nUPDATE employees_temp SET commission_pct = NULL WHERE commission_pct = 0; -- Removed the 0 and made it back to NULL\nCOMMIT;\n\nDROP INDEX comm_pct_idx;\nCREATE BITMAP INDEX comm_pct_idx ON employees_temp(commission_pct) COMPUTE STATISTICS;-- Butmap index indexes NULL values\n\nSELECT employee_id,commission_pct FROM employees_temp WHERE commission_pct IS NULL; -- This also not used the index because the cardinality is high. So it went for full table scan\n\nSELECT /*+ index(employees_temp comm_pct_idx)*/employee_id,commission_pct\nFROM employees_temp WHERE commission_pct IS NULL; --Here it will use the index as NULL values are stored in bitmap index; but the cost is high.\n\nDROP TABLE employees_temp;\n\n")),(0,s.kt)("h3",{id:"using-exists-instead-of-in-clause"},"Using EXISTS instead of IN clause"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"If the outer table is big and the subquery is small, using IN might have a better performance.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"If the outer table is small and the inner table is big, using EXISTS might have a better performance.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"EXISTS doesn't work better than IN all the times. It depends.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"NOT EXISTS is not the equivalent of NOT IN. So it cannot be used instead of NOT IN all the times. Especially if there are any null values, the NOT IN will return nothing.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"The new versions of database generally finds the optimum choice between EXISTS and IN. So you might not see any difference in the execution.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Using IN clause will convert the query like this"))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM T1 WHERE X IN (SELECT X FROM T2);\n\n-- To\n\nSELECT * FROM T1, (SELECT X FROM T2) T2 WHERE T1.X = T2.X); -- Joins every row\n\n")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Using EXISTS will convert the query something like this")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM T1 WHERE EXISTS (SELECT X FROM T2 WHERE T1. = T2.X);\n\n--To\n\nFOR X IN (SELECT * FROM T1) LOOP\nIF (EXISTS (SELECT X FROM T2)) THEN\nOUTPUT THE RECORD\nEND IF:\nEND;--Whenever it finds the value, it stops and return it\n")),(0,s.kt)("h3",{id:"truncate-instead-of-delete"},"TRUNCATE instead of DELETE"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"TRUNCATE is always faster than the DELETE command (Truncate doesn't generate UNDO data,but delete generates)"),(0,s.kt)("li",{parentName:"ul"},"Truncate makes unusable indexes usable again. But delete does not."),(0,s.kt)("li",{parentName:"ul"},"We can truncate a single partition as well."),(0,s.kt)("li",{parentName:"ul"},"TRUNCATE will not trigger any DML triggers. So we cannot track the operations if we are logging DML operations through triggers.")),(0,s.kt)("h3",{id:"data-type-mismatch"},"Data Type Mismatch"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"If the data types of the column and compared value don't match, this may suppress the index usage.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT cust_id, cust_first_name, cust_last_name FROM customers WHERE cust_id = 3228;--This will use the index\n\nSELECT cust_id, cust_first_name, cust_last_name FROM customers WHERE cust_id = '3228';--This will also use the index as well. CUST_ID column is NUMBER datatype. Actually it shouldn't have used the index; but the query is rewritten by the optimizer to increase the performance.\n\nCREATE INDEX cust_postal_code_idx ON customers (cust_postal_code);\n\nSELECT cust_id, cust_first_name, cust_last_name FROM customers WHERE cust_postal_code = 60332;--This has not used the index. Datatype of cust_postal_code is VARCHAR2\n\nSELECT cust_id, cust_first_name, cust_last_name FROM customers WHERE cust_postal_code = '60332';--This used the index\n\nSELECT cust_id, cust_first_name, cust_last_name FROM customers WHERE to_number(cust_postal_code) = 60332;--This increased the cost as it needed to convert all the values in the table to number. Instead convert the value on right side.\n\nDROP INDEX cust_postal_code_idx;\n")),(0,s.kt)("h3",{id:"order-by-clause"},"ORDER BY clause"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Order by mostly requires sort operations"),(0,s.kt)("li",{parentName:"ul"},"The sort operations are done in PGA or discs (If PGA doesn't have enough memory)"),(0,s.kt)("li",{parentName:"ul"},"How to tune the order by clauses?",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"Create or modify B-Tree indexes including the column used in the order by clause. So it will sort the data and store it in index."),(0,s.kt)("li",{parentName:"ul"},"Increase the PGA size. So it will not use the disk (TEMPSPACE in explan plan). Using disk for sorting will decrease the performance than using memory"),(0,s.kt)("li",{parentName:"ul"},"Query for only the indexed columns in the select clause"),(0,s.kt)("li",{parentName:"ul"},"Restrict the returning rows. If the rows are already available in the index, it will be much faster as it does not need to look in the table."))),(0,s.kt)("li",{parentName:"ul"},"BITMAP indexes donot store indexes in sorted order")),(0,s.kt)("h3",{id:"min--max-values"},"MIN & MAX values"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"B-Tree indexes increase the performance a lot for the min & max value searches"),(0,s.kt)("li",{parentName:"ul"},"To find the min or max value, it needs to read the whole table (if there is no B-Tree index)"),(0,s.kt)("li",{parentName:"ul"},"In B-Tree indexes, the rightmost and leftmost leaves have the maximum and minimum values of the indexed column"),(0,s.kt)("li",{parentName:"ul"},"If the returning rows are restricted, this time instead of leftmost and rightmost leaves, some other leaves have the min and max values. But again, it doesn't need to read all the rows of the index."),(0,s.kt)("li",{parentName:"ul"},"If the query has multiple aggregate functions or another column, it will perform index full scan or table access full.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"select min(cust_id) from customers; -- Cost is 2\nselect min(cust_id), max(cust_id) from customers; -- Cost is 33. Because, it needed to read all the index to find min and max value\nSELECT MAX(cust_id), MAX(cust_id) FROM customers;-- Here also, cost is 33. Whenever there is multiple aggregate functions, it will use index full scan or full table scan.\n\nselect * from\n (select min(cust_id) min_cust from customers) min_customer,\n (select max(cust_id) max_cust from customers) max_customer;-- This reduced the cost to 4. It used the index seperately and joined them.\n")),(0,s.kt)("h3",{id:"union-and-union-all"},"UNION and UNION ALL"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"If they return the same results or if you don't care about the duplicates, you should use UNION ALL instead of UNION for performance (UNION ALL doesn't perform sort)")),(0,s.kt)("h3",{id:"avoid-using-having-clause"},"Avoid using HAVING clause"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Having clause restricts the rows after they are read. So predicates/filters in the having clause will not be used as access predicates")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"select time_id,sum(amount_sold) from sales\ngroup by time_id\nhaving time_id between '01-JAN-01' and '28-FEB-01'; -- Cost is 477\n\nselect time_id,sum(amount_sold) from sales\nwhere time_id between '01-JAN-01' and '28-FEB-01'\ngroup by time_id;--Cost is 35\n\nselect prod_id,sum(amount_sold) from sales\ngroup by prod_id\nhaving prod_id = 136;--Cost is 477\n\nselect prod_id,sum(amount_sold) from sales\nwhere prod_id = 136\ngroup by prod_id;--Cost is 146\n")),(0,s.kt)("h3",{id:"views"},"Views"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"If you don't need to use all the tables in a view for your result, do not use that view on your queries. It is better to use only the tables which you need."),(0,s.kt)("li",{parentName:"ul"},"Don't join the complex views with a table or another view. Views are fetched first then it is joined with the other table. This will reduce the performance"),(0,s.kt)("li",{parentName:"ul"},"Avoid performing outer joins to the views"),(0,s.kt)("li",{parentName:"ul"},"Be careful on subquery unnesting"),(0,s.kt)("li",{parentName:"ul"},"Avoid using views inside of a view")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE OR REPLACE VIEW vw_emp_dept AS\nSELECT E.employee_id, E.last_name, E.first_name, E.salary, E.job_id,\n    D.department_id, D.department_name, D.location_id, L.state_province\n    FROM employees E, departments D , locations L\nWHERE E.department_id(+) = D.department_id\nAND D.location_id = L.location_id;\n\nSELECT  V.first_name, V.last_name, j.job_title\nFROM jobs j, vw_emp_dept V\nWHERE j.job_id = 'IT_PROG'\nAND V.job_id = j.job_id;-- This view uses a join with department table. But we dont need the department details in our query. It is better to use the Employees table directly here.\n\nselect * from vw_emp_dept;\n\nSELECT  E.first_name, E.last_name, j.job_title\nFROM employees E, jobs j\nWHERE j.job_id = 'IT_PROG'\nAND E.job_id = j.job_id;\n\n\nCREATE OR REPLACE VIEW vw_cust_num_sold AS\nSELECT C.cust_id, cust_first_name,cust_last_name, prod_id, COUNT(*) num_sold FROM sales S, customers C\nWHERE S.cust_id = C.cust_id\nGROUP BY C.cust_id,cust_first_name, cust_last_name, prod_id\nORDER BY num_sold DESC;\n\nSELECT cust_id,prod_name,num_sold\nFROM vw_cust_num_sold V, products P\nWHERE V.prod_id = P.prod_id\nAND V.prod_id = 13;--Selected the columns from all the table used in the view and products table. Here predicates are pushed into the view to increase the performance.\n")),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(5516).Z,width:"766",height:"323"}),"\n",(0,s.kt)("img",{src:n(4850).Z,width:"889",height:"567"})),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT cust_id,prod_name,num_sold\nFROM vw_cust_num_sold V, products P\nWHERE V.prod_id = P.prod_id(+)\nAND V.prod_id = 13;--Above query and this one returns same result. But we used an outer join here. Since it is an outer join, optimizer could not push the predicates into the view. Hence reduced the performance.\n\n")),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(6822).Z,width:"861",height:"522"})),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT C.cust_id, P.prod_name, COUNT(*) num_sold FROM sales S, customers C, products P\nWHERE S.cust_id = C.cust_id\nAND S.prod_id = P.prod_id(+)\nAND P.prod_id = 13\nGROUP BY C.cust_id, P.prod_name\nORDER BY num_sold DESC; -- Selected from actual table. This has reduced the cost as it is not reading from View and doing outer join. Doing outer join on view will read unnessasary data from the view and donot use the predicates and index well.\n\nDROP VIEW hr.vw_emp_dept;\nDROP VIEW vw_cust_num_sold;\n\n")),(0,s.kt)("h3",{id:"materialized-views"},"Materialized Views"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Unlike the basic and complex views, materialized views store both the query and the data"),(0,s.kt)("li",{parentName:"ul"},"The materialized view data can be refreshed manually or by a PL/SQL job, or by auto-refresh on DMLS"),(0,s.kt)("li",{parentName:"ul"},"Materialized view maintenance also is a burden to the database"),(0,s.kt)("li",{parentName:"ul"},"We can create indexes, partitions etc, on materialized views (Its table is an ordinary table)"),(0,s.kt)("li",{parentName:"ul"},"When query rewrite is enabled in materialized views or in your session, the optimizer may use your materialized view even if you don't query from it. Enabled by default from 11g. So it is better to enable query rewrite option in your materialized view.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT C.cust_id, cust_first_name,cust_last_name, prod_id, COUNT(*) num_sold FROM sales S, customers C\nWHERE S.cust_id = C.cust_id\nGROUP BY C.cust_id,cust_first_name, cust_last_name, prod_id\nORDER BY num_sold DESC;--Cost is 11081\n\nCREATE MATERIALIZED VIEW vw_cust_num_sold\nENABLE QUERY REWRITE AS\nSELECT C.cust_id, cust_first_name,cust_last_name, prod_id, COUNT(*) num_sold FROM sales S, customers C\nWHERE S.cust_id = C.cust_id\nGROUP BY C.cust_id,cust_first_name, cust_last_name, prod_id\nORDER BY num_sold DESC;\n\nSELECT * FROM vw_cust_num_sold; --Cost is 323\n\nSELECT cust_id,prod_name,num_sold\nFROM vw_cust_num_sold V, products P\nWHERE V.prod_id = P.prod_id\nAND V.prod_id = 13; -- Cost is 325\n\nSELECT cust_id,prod_name,num_sold\nFROM vw_cust_num_sold V, products P\nWHERE V.prod_id = P.prod_id(+)\nAND V.prod_id = 13; -- Cost is 325 -- Outer join\n\nSELECT C.cust_id, cust_first_name,cust_last_name, prod_id, COUNT(*) num_sold FROM sales S, customers C\nWHERE S.cust_id = C.cust_id\nAND prod_id = 13\nGROUP BY C.cust_id,cust_first_name, cust_last_name, prod_id\nORDER BY num_sold DESC;--Not used MView but original tables. As we written query rewrite, it used the MView instead of original table here to increase the performance. Cost is 325\n\nDROP MATERIALIZED VIEW vw_cust_num_sold;\n")),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(4198).Z,width:"884",height:"291"})),(0,s.kt)("h3",{id:"avoid-commit-too-much-or-too-less"},"Avoid commit too much or too less"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Commiting too often will result in ORA-1555 error"),(0,s.kt)("li",{parentName:"ul"},"For each DML operations, the database creates UNDO data and REDO data"),(0,s.kt)("li",{parentName:"ul"},"Performing commit frequently will not help on performance (REDO and UNDO data is already carried to discs frequently)"),(0,s.kt)("li",{parentName:"ul"},"Any changes on the same blocks (which are carried to the redo log files) will be created in redo log buffer again"),(0,s.kt)("li",{parentName:"ul"},"Updates and deletes will lock the rows and that will make the other users wait to perform any other operations on these rows"),(0,s.kt)("li",{parentName:"ul"},"How often do we need to commit?",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"As soon as we finish the DML operations"),(0,s.kt)("li",{parentName:"ul"},"For some business-specific reasons"),(0,s.kt)("li",{parentName:"ul"},"If you are updating or inserting millions of rows, performing commit after these operations will be the best."),(0,s.kt)("li",{parentName:"ul"},"If you have any problems with the memory size, increasing the REDO and UNDO size will help you more than committing it often.")))),(0,s.kt)("h3",{id:"partition-pruning"},"Partition Pruning"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"If the query has low selectivity, the optimizer mostly prefers performing full-table scans"),(0,s.kt)("li",{parentName:"ul"},"Creating partitioned tables increases the cost for the queries having low selectivity. But better than doing full-table scans"),(0,s.kt)("li",{parentName:"ul"},"Selecting from specific partitions is called as ",(0,s.kt)("inlineCode",{parentName:"li"},"partition pruning")),(0,s.kt)("li",{parentName:"ul"},"How can we prune the partitions?",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"Selecting directly from the partition by using the partition name"),(0,s.kt)("li",{parentName:"ul"},"Adding predicates to the where clause including the partition key (partitioned columns)")))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"create table sales_temp as select * from sales;--Sales table has partitions. Taking a copy of that table. Partitions will not be copied to the new table.\n\nselect sum(amount_sold) from sales_temp where time_id between '01-JAN-01' and '31-DEC-03';--Cost is 1242. Did a full table scan\n\nselect sum(amount_sold) from sales where time_id between '01-JAN-01' and '31-DEC-03';--Using PARTITION RANGE (ITERATOR), did a full table scan. That means it read from some of the partitions only. Cost is 463\n\ndrop table sales_temp;\n")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Here, optimizer could not decide which partitions to use before running the query. So it witten PARTITION_STOP and PARTITION_START as KEY instead of partition ID. As it has determined which partitions to use while executing, this is called ",(0,s.kt)("inlineCode",{parentName:"li"},"Dynamic Partitioning"))),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(1007).Z,width:"1527",height:"295"})),(0,s.kt)("h3",{id:"bulk-collect"},"BULK COLLECT"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"SQL Codes are executed in SQL Engine & PL/SQL Codes are executed in PL/SQL Engine"),(0,s.kt)("li",{parentName:"ul"},"Transfer of control between SQL Engine and PL/SQL Engine is called as ",(0,s.kt)("inlineCode",{parentName:"li"},"CONTEXT SWITCH")),(0,s.kt)("li",{parentName:"ul"},"BULK COLLECT decreases the context switches (It reads multiple rows in one fetch)"),(0,s.kt)("li",{parentName:"ul"},"Things to know about BULK COLLECT",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"By default, the bulk collect fetches all the rows in one context switch. It may lead to memory problems"),(0,s.kt)("li",{parentName:"ul"},"We can change the fetch count by using the LIMIT keyword to avoid memory errors"))),(0,s.kt)("li",{parentName:"ul"},"Implicit cursors use bulk collect by default"),(0,s.kt)("li",{parentName:"ul"},"You cannot see executions plans for PL/SQL blocks using DBMS_XPLAN but you can use Trace files with TKPROF to find the execution plan")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\nCURSOR c1 IS SELECT cust_id, cust_email FROM customers ORDER BY cust_id;\nTYPE r_type IS TABLE OF c1%rowtype;\nr1 r_type := r_type();\nidx PLS_INTEGER := 0;\nBEGIN\nOPEN c1;\nLOOP\nidx:=idx+1;\nr1.extend;\nFETCH c1 INTO r1(idx);\nEXIT WHEN c1%notfound;\nEND LOOP;\nCLOSE c1;\nEND;\n/\n")),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(739).Z,width:"773",height:"438"}),"\n",(0,s.kt)("img",{src:n(8618).Z,width:"765",height:"264"})),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Fetched 55500 rows and fetch count is 55501. Extra 1 count is to check whether there are any more rows")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\nCURSOR c2 IS SELECT cust_id, cust_email FROM customers ORDER BY cust_id;\nTYPE r_type IS TABLE OF c2%rowtype;\nr1 r_type := r_type();\nBEGIN\nOPEN c2;\nFETCH c2 BULK COLLECT INTO r1;\nCLOSE c2;\nEND;\n/\n")),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(2836).Z,width:"762",height:"328"}),"\n",(0,s.kt)("img",{src:n(8893).Z,width:"760",height:"277"})),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"In one fetch it returned all 55500 rows")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\nCURSOR c3 IS SELECT cust_id, cust_email FROM customers ORDER BY cust_id;\nTYPE r_type IS TABLE OF c3%rowtype;\nr1 r_type := r_type();\nBEGIN\nOPEN c3;\nFETCH c3 BULK COLLECT INTO r1 LIMIT 100;\nCLOSE c3;\nEND;\n/\n")),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(5383).Z,width:"872",height:"394"}),"\n",(0,s.kt)("img",{src:n(1749).Z,width:"865",height:"329"})),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"It read 100 rows in one fetch")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\nCURSOR c4 IS SELECT cust_id, cust_email FROM customers ORDER BY cust_id;\nTYPE r_type IS TABLE OF c4%rowtype;\nr1 r_type := r_type();\nBEGIN\nOPEN c4;\nLOOP\nFETCH c4 BULK COLLECT INTO r1 LIMIT 100;\nEXIT WHEN c4%notfound;\nEND LOOP;\nCLOSE c4;\nEND;\n/\n")),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(7478).Z,width:"835",height:"420"}),"\n",(0,s.kt)("img",{src:n(9536).Z,width:"839",height:"315"})),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"It fetched for 556 times")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\nCURSOR c5 IS SELECT cust_id, cust_email FROM customers ORDER BY cust_id;\nTYPE r_type IS TABLE OF c5%rowtype;\nr1 r_type := r_type();\nBEGIN\nOPEN c5;\nLOOP\nFETCH c5 BULK COLLECT INTO r1 LIMIT 1000;\nEXIT WHEN c5%notfound;\nEND LOOP;\nCLOSE c5;\nEND;\n/\n")),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(5869).Z,width:"904",height:"455"}),"\n",(0,s.kt)("img",{src:n(8421).Z,width:"909",height:"330"})),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Fetched for 56 times")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\nCURSOR c6 IS SELECT cust_id, cust_email FROM customers ORDER BY cust_id;\nTYPE r_type IS TABLE OF c6%rowtype;\nr1 r_type := r_type();\nBEGIN\nOPEN c6;\nLOOP\nFETCH c6 BULK COLLECT INTO r1 LIMIT 100000;\nEXIT WHEN c6%notfound;\nEND LOOP;\nCLOSE c6;\nEND;\n/\n")),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(3269).Z,width:"987",height:"963"})),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Results in same as the bulk collect without LIMIT"),(0,s.kt)("li",{parentName:"ul"},"Here it showed limiting the rows to 1000 performed better than fetching all rows at once. It can be different in different system and for different queries.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\nTYPE r_type IS TABLE OF varchar2(100) index by pls_integer;\nr1 r_type;\nBEGIN\nFOR r2 IN (SELECT cust_id, cust_email FROM customers ORDER BY cust_id) LOOP\nr1(r2.cust_id) := r2.cust_email;\nEND LOOP;\nEND;\n/\n")),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(1928).Z,width:"1000",height:"872"})),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"This is an implicit cursor."),(0,s.kt)("li",{parentName:"ul"},"By default, implicit cursor limit the rows to 100")),(0,s.kt)("h3",{id:"join-order"},"Join Order"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Driving table are read by full scan"),(0,s.kt)("li",{parentName:"ul"},"If one table has index and other does not, we should select table with index as inner table"),(0,s.kt)("li",{parentName:"ul"},"If both table has index, we should select smaller table as driving table.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT /*+ ORDERED */P.prod_name,C.cust_first_name,S.amount_sold FROM  customers C, products P, sales S\nWHERE S.cust_id = C.cust_id\nAND P.prod_id = S.prod_id; -- Cost is 87458\n")),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(181).Z,width:"952",height:"365"})),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Customer table as driving table and performed merge join with product table and joined with sales table")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT /*+ ORDERED */P.prod_name,C.cust_first_name,S.amount_sold FROM sales S, customers C, products P\nWHERE S.prod_id = P.prod_id\nAND S.cust_id = C.cust_id;\n")),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(7210).Z,width:"936",height:"503"})),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Sales table as driving table; taken data from customer table using index column CUST_ID")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT /*+ ORDERED */P.prod_name,C.cust_first_name,S.amount_sold FROM sales S, products P , customers C\nWHERE S.prod_id = P.prod_id\nAND S.cust_id = C.cust_id;\n")),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(9674).Z,width:"944",height:"479"})),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Sales table as driving table; taken data from product table using index column PROD_ID")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT /*+ ORDERED */P.prod_name,C.cust_first_name,S.amount_sold FROM  products P , sales S, customers C\nWHERE S.prod_id = P.prod_id\nAND S.cust_id = C.cust_id;\n")),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(1734).Z,width:"949",height:"527"})),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Products table as driving table; taken data from sales table using index column PROD_ID"),(0,s.kt)("li",{parentName:"ul"},"Product table is the smaller table here.")),(0,s.kt)("h3",{id:"multitable-dml-operations"},"Multitable DML operations"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"------------------------ INSERT ALL EXAMPLE -----------------------------\n\nCREATE TABLE it_programmers AS SELECT * FROM employees WHERE 1=2;\n\nCREATE TABLE sales_representatives AS SELECT * FROM employees WHERE 1=2;\n\n--Below 2 queries trying to insert data into new tables using 2 different queries\nINSERT INTO it_programmers SELECT * FROM employees WHERE job_id = 'IT_PROG';\n\nINSERT INTO sales_representatives SELECT * FROM employees WHERE job_id = 'SA_REP';\n")),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(1082).Z,width:"1827",height:"561"}),"\n",(0,s.kt)("img",{src:n(9910).Z,width:"1677",height:"605"})),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"--Below query does the same thing as above but in a single statement. So instead of reading the employees table multiple times, it read in single time. It will improve the performance.\nINSERT ALL\n    WHEN job_id = 'IT_PROG' THEN INTO it_programmers\n    WHEN job_id = 'SA_REP' THEN INTO sales_representatives\nSELECT * FROM employees WHERE job_id IN ('IT_PROG','SA_REP');\n")),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(4445).Z,width:"1696",height:"619"})),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"-------------------------- MERGE EXAMPLE --------------------------------\n\nCREATE TABLE bonuses (employee_id NUMBER(6,0), bonus NUMBER(8,2), salary NUMBER(8,2), department_id NUMBER(4,0));\n\nINSERT INTO bonuses SELECT employee_id, 1000, salary, department_id FROM employees WHERE ROWNUM < 70;\n\nINSERT INTO bonuses SELECT employee_id, 1000, salary, department_id FROM employees WHERE department_id = 80 AND salary < 10000\nAND employee_id NOT IN (SELECT employee_id FROM bonuses);\n\nUPDATE bonuses b SET b.bonus = b.bonus + bonus*0.15\nWHERE employee_id IN (SELECT employee_id FROM employees WHERE department_id = 80 AND salary < 10000);\n\nDELETE FROM bonuses WHERE employee_id IN (SELECT employee_id FROM employees WHERE salary >= 10000 OR department_id <> 80);\n\n")),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(5659).Z,width:"1694",height:"540"}),"\n",(0,s.kt)("img",{src:n(4421).Z,width:"1624",height:"531"}),"\n",(0,s.kt)("img",{src:n(5785).Z,width:"1613",height:"677"})),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"MERGE INTO bonuses b\n   USING (SELECT employee_id, salary, department_id FROM employees) E\n   ON (b.employee_id = E.employee_id )\n   WHEN MATCHED THEN\n     UPDATE SET b.bonus = b.bonus + b.bonus*0.15\n     DELETE WHERE (b.salary >= 10000 OR b.department_id != 80)\n   WHEN NOT MATCHED THEN\n   INSERT (b.employee_id, b.bonus, b.salary, b.department_id)\n     VALUES (E.employee_id, 1000 + 1000*0.15, E.salary, E.department_id)\n     WHERE (E.salary < 10000 AND E.department_id = 80);\n\nDROP TABLE it_programmers;\nDROP TABLE sales_representatives;\nDROP TABLE bonuses;\n")),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(6580).Z,width:"1703",height:"780"})),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Here lot more recursive cursors are there for merge as there are multiple operations. That is not shown in this screenshot")),(0,s.kt)("h3",{id:"temporary-tables"},"Temporary Tables"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"From 18C you can create private temporary table."),(0,s.kt)("li",{parentName:"ul"},"Private temporary tables are only visible to your session and the table is dropped once the session ends."),(0,s.kt)("li",{parentName:"ul"},"You should not create temporary table if it is not used for couple of times as creating temporary table also involves cost. So you should be able to justify the creation of temporary table."),(0,s.kt)("li",{parentName:"ul"},"You can consider it like a materialized view; but for a single session")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT P.prod_name,C.cust_first_name,sum(S.amount_sold) sold FROM  products P , sales S, customers C\nWHERE S.prod_id = P.prod_id\nAND S.cust_id = C.cust_id\ngroup by p.prod_name, c.cust_first_name\nhaving sum(amount_sold) > 10\norder by sold; -- Cost: 918\n\nSELECT P.prod_name,C.cust_first_name,sum(S.amount_sold) sold FROM  products P , sales S, customers C\nWHERE S.prod_id = P.prod_id\nAND S.cust_id = C.cust_id\nand p.prod_name like 'DVD-R%'\ngroup by p.prod_name, c.cust_first_name\norder by sold;--Cost: 797\n\nSELECT P.prod_name,C.cust_first_name,sum(S.amount_sold) sold FROM  products P , sales S, customers C\nWHERE S.prod_id = P.prod_id\nAND S.cust_id = C.cust_id\nand p.prod_name like 'CD-R%'\ngroup by p.prod_name, c.cust_first_name\norder by sold;--Cost: 865\n\ncreate global temporary table products_sum_sold_amount(prod_name, cust_first_name, sum_amount_sold)\non commit preserve rows as\nSELECT P.prod_name,C.cust_first_name,sum(S.amount_sold) sold FROM  products P , sales S, customers C\nWHERE S.prod_id = P.prod_id\nAND S.cust_id = C.cust_id\ngroup by p.prod_name, c.cust_first_name\norder by sold; -- Cost:5964\n\nSELECT prod_name,cust_first_name, sum_amount_sold FROM  products_sum_sold_amount\nWHERE sum_amount_sold > 10;--Cost: 110\n\nSELECT prod_name,cust_first_name, sum_amount_sold FROM  products_sum_sold_amount\nWHERE prod_name like 'DVD-R%';--Cost: 110\n\nSELECT prod_name,cust_first_name, sum_amount_sold FROM  products_sum_sold_amount\nWHERE prod_name like 'CD-R%';--Cost: 110\n")),(0,s.kt)("h3",{id:"combining-sql-statements"},"Combining SQL statements"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Combining similar SQL statement may increase the performance as they need to run only once.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT MAX(S.amount_sold) max_sold FROM products P , sales S, customers C\nWHERE S.prod_id = P.prod_id\nAND S.cust_id = C.cust_id\nAND P.prod_id = 13;--Cost: 360\n\nSELECT COUNT(S.amount_sold) count_sold FROM products P , sales S, customers C\nWHERE S.prod_id = P.prod_id\nAND S.cust_id = C.cust_id\nAND C.cust_first_name = 'Brant';--Cost: 854\n\nSELECT AVG(S.amount_sold) avg_sold FROM products P , sales S, customers C\nWHERE S.prod_id = P.prod_id\nAND S.cust_id = C.cust_id\nAND P.prod_category = 'Photo';--Cost: 462\n\nSELECT\nMAX(decode(P.prod_id,13,S.amount_sold,0)) max_sold,\nSUM(decode(C.cust_first_name,'Brant',1,0)) count_sold,\nSUM(decode(P.prod_category,'Photo',amount_sold)) / SUM(decode(P.prod_category,'Photo',1)) avg_sold\nFROM products P , sales S, customers C\nWHERE S.prod_id = P.prod_id\nAND S.cust_id = C.cust_id;--Cost: 862\n")),(0,s.kt)("h3",{id:"with-clause"},"WITH clause"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Like temporary table and materialized view, oracle stores the result of the queries in user's temp space."),(0,s.kt)("li",{parentName:"ul"},"Often interchangeably called CTE (common table expression) or subquery refactoring"),(0,s.kt)("li",{parentName:"ul"},"If the result is not very big, it stores the data as a view in memory"),(0,s.kt)("li",{parentName:"ul"},"If the result is big, it stores the data in a global temporary table automatically created for that query. It will be slower than memory.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT prod_name,\n    (SELECT SUM(amount_sold) amt_sold FROM sales WHERE prod_id = P.prod_id) / (SELECT COUNT(*) num_prods FROM products)\nFROM products P\nWHERE P.prod_id IN (SELECT prod_id FROM sales GROUP BY prod_id HAVING SUM(amount_sold) > 100000);--Cost:1251\n\nWITH sum_amount AS\n        (SELECT SUM(amount_sold) amt_sold, prod_id FROM sales GROUP BY prod_id),\n     num_of_prods AS\n        (SELECT COUNT(*) num_prods FROM products)\nSELECT prod_name,\n    amt_sold / (SELECT num_prods FROM num_of_prods)\nFROM products P, sum_amount S\nWHERE P.prod_id = S.prod_id\nAND amt_sold > 100000;--Cost:481\n\n\nSELECT DISTINCT S.cust_id,S.prod_id,S.amount_sold,\n(SELECT AVG(amount_sold) avg_sold FROM sales s1 WHERE channel_id = 2\n        AND S.prod_id = s1.prod_id) avg_sold ,\n(SELECT COUNT(s2.amount_sold) amt_sold FROM customers c2, sales s2\n        WHERE s2.cust_id = c2.cust_id\n              AND c2.cust_marital_status = 'married'\n              AND S.cust_id = s2.cust_id\n              GROUP BY c2.cust_first_name,c2.cust_last_name,c2.cust_id) amt_sold\nFROM  sales S\nWHERE S.channel_id = 2\nAND S.amount_sold >\n    (SELECT AVG(amount_sold) avg_sold FROM sales s1 WHERE channel_id = 2 AND S.prod_id = s1.prod_id)\nAND (SELECT COUNT(s2.amount_sold) amt_sold FROM customers c2, sales s2\n        WHERE s2.cust_id = c2.cust_id\n              AND c2.cust_marital_status = 'married'\n              AND S.cust_id = s2.cust_id\n              GROUP BY c2.cust_first_name,c2.cust_last_name,c2.cust_id) > 200\nORDER BY cust_id,prod_id;--Cost: 425411\n\n\n\nWITH avg_amounts_per_prod AS\n        (SELECT AVG(amount_sold) avg_sold, prod_id FROM sales WHERE channel_id = 2 GROUP BY prod_id),\n    amounts_sold AS\n        (SELECT C.cust_first_name, C.cust_last_name, C.cust_id, COUNT(S.amount_sold) tot_amt_sold FROM customers C, sales S\n            WHERE S.cust_id = C.cust_id\n                  AND C.cust_marital_status = 'married'\n                  GROUP BY C.cust_first_name,C.cust_last_name,C.cust_id)\nSELECT DISTINCT S.cust_id,S.prod_id,S.amount_sold,\n(SELECT avg_sold FROM avg_amounts_per_prod A WHERE A.prod_id = S.prod_id) avg_sold,\n(SELECT tot_amt_sold FROM amounts_sold T WHERE T.cust_id = S.cust_id)\nFROM  sales S\nWHERE S.channel_id = 2\nAND S.amount_sold > (SELECT avg_sold FROM avg_amounts_per_prod A WHERE A.prod_id = S.prod_id)\nAND (SELECT tot_amt_sold FROM amounts_sold T WHERE T.cust_id = S.cust_id) > 200\nORDER BY cust_id,prod_id;--Cost: 5804\n")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Temporary tables created for WITH clause\n",(0,s.kt)("img",{src:n(1139).Z,width:"1058",height:"674"}))),(0,s.kt)("h3",{id:"analytical-functions"},"Analytical Functions"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"select e1.employee_id, e1.first_name, e1.last_name,\n       e1.department_id, e1.salary, e3.next_sal, e2.avg_sal\nfrom employees e1,\n    (select department_id, round(avg(salary),2) as avg_sal from employees\n     group by department_id) e2,\n    (select employee_id, salary next_sal from employees) e3\nwhere e1.department_id = e2.department_id(+)\nand e1.employee_id+1 = e3.employee_id(+)\norder by e1.employee_id;--Cost: 10; Read Employees table 3 times\n\nselect employee_id, first_name, last_name, department_id, salary,\n       lead(salary,1) over (order by employee_id) next_sal,\n       round(avg(salary) over (partition by department_id),2) as avg_sal\nfrom employees\norder by employee_id;--Cost: 4; Read Employees table once\n")),(0,s.kt)("h2",{id:"composite-indexes"},"Composite Indexes"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Composite indexes are the ones created for multiple columns"),(0,s.kt)("li",{parentName:"ul"},"Maximum if 32 columns can be combined for b-tree index and 30 columns for bitmap index"),(0,s.kt)("li",{parentName:"ul"},"Advantages of composite indexes:",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"Higher Selectivity"),(0,s.kt)("li",{parentName:"ul"},"Less I/O; If the columns are there in index already, it does not need to read from table"),(0,s.kt)("li",{parentName:"ul"},"Can be used for one or multiple columns. So even if we don't use all the columns, it can make use of the index.\n-But if we donot include the first column in the index, it may perform index skip scan or index full scan. But that is not guaranteed.",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"Even if it perform index skip scan or index full scan, it will be slower than index range scan."),(0,s.kt)("li",{parentName:"ul"},"What if our work clause includes first and third columns of the index?\nIn this case, the optimizer will check the selectivity of the first column.If it is selective enough, it will read from the index by using the first column and then perform a filter predicate with the third column because they are not consecutive."),(0,s.kt)("li",{parentName:"ul"},"But if you select the first and second columns this time, it will select for the concatenation of these two columns, and this will be faster than the previous one."))))),(0,s.kt)("li",{parentName:"ul"},"Selecting the column order is important in composite indexes"),(0,s.kt)("li",{parentName:"ul"},"You should put most queried condition column as first and then second and so on. If multiple columns are used in same priority, you should put more selective column first and the next and so on")),(0,s.kt)("h2",{id:"covering-indexes"},"Covering Indexes"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"It is not an actual index type"),(0,s.kt)("li",{parentName:"ul"},"An index including all the columns of the query is called ",(0,s.kt)("inlineCode",{parentName:"li"},"covering index")," for that query"),(0,s.kt)("li",{parentName:"ul"},"Benefits of covering indexes:",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"There is no need to look up the data in the table"),(0,s.kt)("li",{parentName:"ul"},"Needs less I/O operations"))),(0,s.kt)("li",{parentName:"ul"},"Drawbacks of covering indexes:",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"Increase the index size"),(0,s.kt)("li",{parentName:"ul"},"Will be used for fewer queries"),(0,s.kt)("li",{parentName:"ul"},"Maintenance cost increases")))),(0,s.kt)("h2",{id:"reverse-key-index"},"Reverse key index"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Simultaneous inserts/updates from multiple instances on the indexed tables may have performance problems because of the index maintenance (especially for the sequential va lues)"),(0,s.kt)("li",{parentName:"ul"},"Sequential value inserts may cause contention in the index blocks with some waits or locks"),(0,s.kt)("li",{parentName:"ul"},"Reverse key index is not an index used by reverse function on the indexed column!"),(0,s.kt)("li",{parentName:"ul"},"Reverse key indexes store the bytes of the indexed columns in reverse order (ROWIDs are not reversed)"),(0,s.kt)("li",{parentName:"ul"},"Reversing the bytes will lead the database to store them in different index blocks"),(0,s.kt)("li",{parentName:"ul"},"Drawbacks of reverse key indexes :",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"It works with only the equality searches. So range scan or skip scan won't work here"),(0,s.kt)("li",{parentName:"ul"},"It uses more CPU to reverse the key values")))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE INDEX ix ON temp(a,b) REVERSE;\n")),(0,s.kt)("h2",{id:"index-organized-tables-1"},"Index-Organized tables"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Store the non-key columns as well, in the index leaves"),(0,s.kt)("li",{parentName:"ul"},"There is not a table in addition to an index. Just the index. If we add b-tree index for all the columns for a table, it will use much storage than the original table and it also uses storage for the actual table also. Here it is just index."),(0,s.kt)("li",{parentName:"ul"},"Store the rows in the order of primary key values. (Heap organized tables (normal table) are not ordered in the table)"),(0,s.kt)("li",{parentName:"ul"},"It reads faster than the ordinary indexes over the primary key values"),(0,s.kt)("li",{parentName:"ul"},"The changes are only over the index (since there is no table)"),(0,s.kt)("li",{parentName:"ul"},"It needs less storage (no duplicate columns or rows)"),(0,s.kt)("li",{parentName:"ul"},"Have full-functionality of ordinary tables (all the objects including indexes can be created over index-organized tables)"),(0,s.kt)("li",{parentName:"ul"},"Primary keys can be composite key"),(0,s.kt)("li",{parentName:"ul"},"Restrictions & Disadvantages of ITs (Index-Organized Tables) :",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"Cannot create IOTs with a bitmap index."),(0,s.kt)("li",{parentName:"ul"},"Needs to have a unique primary key"),(0,s.kt)("li",{parentName:"ul"},"Can have max 1000 columns (255 in index portion - rest in the overflow segment)"),(0,s.kt)("li",{parentName:"ul"},"Primary keys can have max 32 columns"),(0,s.kt)("li",{parentName:"ul"},"Cannot contain virtual columns"),(0,s.kt)("li",{parentName:"ul"},"PCTTRESHOLD size cannot be larger than 50% of the index block"),(0,s.kt)("li",{parentName:"ul"},"Faster in updates but slower in inserts. Head organized table will put inserted row into random block. But IOT need to keep the order of the primary key."),(0,s.kt)("li",{parentName:"ul"},"There is no physical rowid in IOTs.There are logical rowids. Because the ROWID always change as it need to keep the order."),(0,s.kt)("li",{parentName:"ul"},"Secondary indexes use logical rowids which makes it work slower"))),(0,s.kt)("li",{parentName:"ul"},"When to use IOTs",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"If the WHERE clauses mostly have the primary key column, but SELECT clause queries for other columns as well"),(0,s.kt)("li",{parentName:"ul"},"Queries returning for small number of rows"),(0,s.kt)("li",{parentName:"ul"},"If the table data is not so often changing (not much inserts)"),(0,s.kt)("li",{parentName:"ul"},"If you don't need additional indexes over the IOTs"),(0,s.kt)("li",{parentName:"ul"},"If the table is small in both row count and column count"),(0,s.kt)("li",{parentName:"ul"},"If an index already needs the majority of the columns")))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE customers _iot (cust _id NUMBER,\ncust first name VARCHAR2(20),\ncust last name VARCHAR2(40),\ncust_gender\nCHAR(1),\ncust year of birth\nNUMBER (4,0),\ncust marital status\nVARCHAR2 (20),\nCONSTRAINT cid pk PRIMARY KEY (cust id))\nORGANIZATION INDEX\nTABLESPACE iot_tbs\nPCTTHRESHOLD 20 -- Specifies the mazimum length of a row in the index block size. Here it says it cannot exceed 20% of the block size. If it exeeds it will store in  OVERFLOW TABLESPACE. If the first 3 columns fills the 20%, it will store the rest in overflow tablespace so if you want to get these columns, it will be slower than the first three columns.\nINCLUDING cust_year_of_birth -- If you want some non-key columns to store in index area. So if you select these columns with primary key column, it will not go to overflow tablespace and it will improve the performance. If the columns in including clause also exit the PCT threshold size, some columns from including columns will be stored in overflow tablespace.\nOVERFLOW TABLESPACE iot_tbs2:\n\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE customers_temp AS\nSELECT cust_id,cust_first_name,cust_last_name,cust_gender,cust_year_of_birth,\ncust_marital_status,cust_postal_code,cust_city_id,cust_credit_limit FROM customers;\n\nCREATE INDEX cus_ix ON customers_temp(cust_id);\n\nCREATE TABLE customers_iot (cust_id NUMBER,\ncust_first_name VARCHAR2(20),\ncust_last_name VARCHAR2(40),\ncust_gender CHAR(1),\ncust_year_of_birth NUMBER(4,0),\ncust_marital_status VARCHAR2(20),\ncust_postal_code VARCHAR2(10),\ncust_city_id NUMBER,\ncust_credit_limit NUMBER,\nCONSTRAINT cid_pk PRIMARY KEY (cust_id))\nORGANIZATION INDEX\nPCTTHRESHOLD 40;\n\nINSERT INTO customers_iot SELECT cust_id,cust_first_name,cust_last_name,cust_gender,cust_year_of_birth,\ncust_marital_status,cust_postal_code,cust_city_id,cust_credit_limit FROM customers;\n\n/\nSELECT * FROM customers_temp WHERE cust_id = 47006; -- Cost 2\nSELECT * FROM customers_iot WHERE cust_id = 47006; -- Cost 1; IOT table\nSELECT * FROM customers_temp WHERE cust_id BETWEEN 5000 AND 5050; -- Cost 29\nSELECT * FROM customers_iot WHERE cust_id BETWEEN 5000 AND 5050; -- Cost 5; IOT table\nSELECT * FROM customers_temp WHERE cust_id BETWEEN 5000 AND 10000; -- Cost: 109; Full table scan\nSELECT * FROM customers_iot WHERE cust_id BETWEEN 5000 AND 10000; -- Cost 5\nSELECT * FROM customers_temp WHERE cust_year_of_birth = 1978; -- Non primary key column in WHERE clause; Full table scan; Cost 110\nSELECT * FROM customers_iot WHERE cust_year_of_birth = 1978;-- Non primary key column in WHERE clause; Fast full scan; Cost 238\n\nDROP TABLE customers_temp;\nDROP TABLE customers_iot;\n")),(0,s.kt)("h2",{id:"invisible-indexes"},"Invisible Indexes"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Creating index will take time. So in order to not affecting the performance, you can create new index as invisible and then make the original one invisible and then make the new one visible."),(0,s.kt)("li",{parentName:"ul"},"Reasons to make an index invisible :",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"Compare the performance with the new one before changing it"),(0,s.kt)("li",{parentName:"ul"},"Check if dropping that index results in some problems"))),(0,s.kt)("li",{parentName:"ul"},"Invisible indexes are also alive like the visible indexes. But the optimizer ignores them"),(0,s.kt)("li",{parentName:"ul"},"OPTIMIZER_USE_INVISIBLE_INDEXES parameter can be set to TRUE to make the optimizer use the invisible indexes. By default it is FALSE"),(0,s.kt)("li",{parentName:"ul"},"Invisible indexes are maintained by the database")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM user indexes WHERE visibility = 'INVISIBLE';\nALTER INDEX ix INVISIBLE;\nALTER INDEX ix VISIBLE;\nCREATE INDEX ix ON TEMP(a,b) INVISIBLE;\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"create table customers_temp as select * from customers;\n\nselect * from customers_temp;\n\ncreate index name_idx on customers_temp(cust_first_name,cust_last_name);\n\nselect * from customers_temp where cust_first_name = 'Arnold';\n\nalter index name_idx invisible;\nalter index name_idx visible;\n\ncreate bitmap index name_bidx on customers_temp(cust_first_name,cust_last_name);\n\ndrop table customers_temp;\n")),(0,s.kt)("h2",{id:"full-text-search-indexes"},"Full-Text search indexes"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"As you know, we can perform search operations all over the indexes by using the like operator. However, this is not so efficient in so many cases."),(0,s.kt)("li",{parentName:"ul"},"To solve such performance problems, Oracle developed the full text indexing in Oracle text."),(0,s.kt)("li",{parentName:"ul"},"Actually Oracle text, previously known as intermediate text or context, is a very detailed subject."),(0,s.kt)("li",{parentName:"ul"},"Oracle text is an extensive full text indexing technology, which allows us to perform free text queries in various ways."),(0,s.kt)("li",{parentName:"ul"},"There are three types of Oracle text indexes. They aim to different type of searches.")),(0,s.kt)("h3",{id:"context-type-index"},"CONTEXT Type Index"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Performs search operations over large documents (PDF, MS Word, XML, HTML, Plain Text)"),(0,s.kt)("li",{parentName:"ul"},"Converts the words in the documents into tokens"),(0,s.kt)("li",{parentName:"ul"},"Documents are stored in BLOB or CLOB type columns")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE my_doc (id NUMBER (10) NOT NULL,\nname VARCHAR2 (200) NOT NULL,\ndocument BLOB NOT NULL);\n\nCREATE INDEX my_doc_idx ON my_docs(document) INDEXTYPE IS CTXYS.CONTEXT;\n\nSELECT name FROM my_doc WHERE CONTAINS (document, 'Search Text') > 0;\n\nSELECT SCORE(1) score, name FROM my_doc\nWHERE CONTAINS (document,'Search Text', 1) > 0\nORDER BY SCORE (1) DESC;\n")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Score Operator returns the relevance score of the row for the specified search text"),(0,s.kt)("li",{parentName:"ul"},"This score is calculated based on Salton's frequency formula.")),(0,s.kt)("h3",{id:"ctxcat-type-index"},"CTXCAT Type Index"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Ideal for smaller documents or text fragments"),(0,s.kt)("li",{parentName:"ul"},"Larger than the context index and takes longer to build"),(0,s.kt)("li",{parentName:"ul"},"It creates indexes over the index sets")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"EXEC CTX_DDL.CREATE_INDEX_SET('products_iset');\n\nEXEC CTX_DDL.ADD_INDEX('products_iset', 'prod_list_price');\n\nCREATE INDEX my_products_name idx ON products (prod desc) INDEXTYPE IS CTXSYS.CTXCAT PARAMETERS ('index set products_iset');\n\nSELECT prod_id, prod_list_price, prod_name, prod_subcategory FROM products WHERE CATSEARCH (prod_desc,'CD', 'prod_list_price > 10' > 0;\n")),(0,s.kt)("h3",{id:"ctxrule-type-index"},"CTXRULE Type Index"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Used to build a document classification application"),(0,s.kt)("li",{parentName:"ul"},"Documents inside of the table are classified based on their contents"),(0,s.kt)("li",{parentName:"ul"},"Used for the category searches")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE INDEX temp_rule ON temp_table(text) INDEXTYPE IS CTXSYS.CTXRULE;\n\nSELECT CLASSIFICATION FROM temp_table\nWHERE matches (text, 'Lionel Messi is a famous footballer from Argentina') > 0;\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"--CTXCAT Type\nGRANT EXECUTE ON ctxsys.ctx_ddl TO sh;\n\nCREATE TABLE products_temp AS SELECT * FROM products;\n\nEXEC ctx_ddl.create_index_set('products_iset'); -- Create an index set to store sub indexes\n\nEXEC ctx_ddl.add_index('products_iset','prod_list_price'); -- Create subindex\n\n--EXEC CTX_DDL.REMOVE_INDEX('products_iset','price'); -- To remove sub index\n\nCREATE INDEX my_products_name_idx ON products_temp(prod_desc) INDEXTYPE IS ctxsys.ctxcat\nPARAMETERS ('index set products_iset');\n\nSELECT prod_id, prod_list_price, prod_name,prod_subcategory,prod_desc\nFROM   products_temp\nWHERE  catsearch(prod_desc, 'CD', 'prod_list_price > 10')> 0;\n")),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(3664).Z,width:"1791",height:"361"}),"\n",(0,s.kt)("img",{src:n(5781).Z,width:"1188",height:"244"})),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT prod_id, prod_list_price, prod_name,prod_subcategory,prod_desc FROM products\nWHERE prod_desc LIKE '%CD%' AND prod_list_price > 10;\n\n")),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(3634).Z,width:"1871",height:"372"}),"\n",(0,s.kt)("img",{src:n(6141).Z,width:"1327",height:"277"})),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"\nDROP INDEX my_products_name_idx;\nDROP TABLE products_temp;\n\n----CTXRULE Type\nCREATE TABLE temp_table(CLASSIFICATION VARCHAR2(50),text VARCHAR2(2000));\n\nINSERT INTO temp_table VALUES('US Politics', 'democrat or republican');\nINSERT INTO temp_table VALUES('Music', 'ABOUT(music)');\nINSERT INTO temp_table VALUES('Football', 'footballer');\nINSERT INTO temp_table VALUES('Countries', 'United States or Great Britain or Argentina');\nINSERT INTO temp_table VALUES('Names', 'Lionel NEAR Messi OR David or Ronaldo');\n\nCREATE INDEX temp_rule ON temp_table(text) INDEXTYPE IS ctxsys.ctxrule;\n\nSELECT CLASSIFICATION FROM temp_table WHERE matches(text, 'Lionel Messi is a famous footballer from Argentina') > 0;\n\n")),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(8039).Z,width:"407",height:"203"}),"\n",(0,s.kt)("img",{src:n(2133).Z,width:"1358",height:"219"})),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"\nEXEC ctx_ddl.drop_index_set('products_iset');\nDROP TABLE temp_table;\n\n")),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://docs.oracle.com/cd/A64702_01/doc/cartridg.805/a63821/ling.htm#7641"},"https://docs.oracle.com/cd/A64702_01/doc/cartridg.805/a63821/ling.htm#7641"),"\n",(0,s.kt)("a",{parentName:"p",href:"https://docs.oracle.com/cd/A64702_01/doc/cartridg.805/a63821/know.htm#38324"},"https://docs.oracle.com/cd/A64702_01/doc/cartridg.805/a63821/know.htm#38324")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"These indexes are very big and complex in comparison to the standard indexes. So it might be very costly to maintain these indexes because it needs to have a full table scan and lots of internal parsing operations. Because of that, it is not so practical to update these indexes for each change in the base tables. Actually most of them are not updated automatically by default, but we can synchronize these indexes manually. We can execute:")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"EXEC CTX_DDL.SYNC_INDEX('my_docs_idx');\n")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"This is the fastest way. However, in time, the index structure will not be so optimal.It is recommend you to optimize your index periodically by using the optimize index package.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"EXEC CTX_DDL.OPTIMIZE_INDEX('my_docs_idx', 'FULL'); -- FAST|FULL|TOKEN\n")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"The ",(0,s.kt)("strong",{parentName:"li"},"FAST mode")," compacts the fragmented rows but doesn't remove the old data. So it is fast"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Full mode")," rebuilds the entire index or a portion of it, but it removes the old data"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Token")," performs full optimization for a specific token.")))}m.isMDXComponent=!0},9015:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2022-12-31-04-41-44-fea4aa7c8663828fb88e5346f0b0a300.png"},7059:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2022-12-31-04-50-07-55fb651661e7640a19e60456bddfbb50.png"},441:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2022-12-31-04-51-24-274740e287d5f6bac1f007eff2112d6c.png"},1222:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2022-12-31-17-21-42-00dd6e548d16065a0caeb6072764a3c0.png"},504:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-03-04-20-30-4dda4af501c84576f61482aa16e0f41f.png"},8565:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-03-04-29-37-de18b2cc283139909bce2c8c6523a02f.png"},9680:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-03-04-41-47-88960bb6c6409c91dd0eee4c08a4b31b.png"},285:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-03-04-51-56-acd5dc2bdcfd714ccad6e7f13e276af7.png"},5516:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-07-12-13-00-4f440c321a06728954cdb5936304afbc.png"},4850:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-07-12-18-45-90578e3f422ef48093b4830213c74c5b.png"},6822:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-07-12-19-13-210ff8d4c682ce8fb368fcfa12b4555e.png"},4198:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-07-12-32-19-6a543ef3ee7a413e325a0161ab9ab8ab.png"},1007:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-07-12-50-17-1d8c7dbec03c9d5f6f430d0fc36f369e.png"},739:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-07-14-08-49-138745df8fa2f4153d62d6166ac690c5.png"},8618:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-07-14-09-43-2daa207b046505105c62704ae423c4a7.png"},2836:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-07-14-10-55-17416d9ffea66ad5fddc3f2f17813388.png"},8893:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-07-14-11-24-d1985af737cd68d0b8cb605db6cbdf66.png"},5383:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-07-14-12-24-a8c2964ae8cf72999e2e17297bf8ce67.png"},1749:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-07-14-12-50-9317225d649a7cd66240239de1197c62.png"},7478:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-07-14-13-46-115966ca13e6ef9cd3bbbca313986c2c.png"},9536:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-07-14-14-12-56f2a45466782c72d5ef0a3e081bf04e.png"},5869:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-07-14-15-08-1a8527b2ed4cddfdaa94fca8e7c5c965.png"},8421:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-07-14-15-33-8174e46429c2c4474254da1c7a59ba1e.png"},3269:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-07-14-16-27-faadeacd993d0d3fc9d90b4b03c4539e.png"},1928:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-07-14-19-20-aaa1f97846e75be87063fce16b5650b8.png"},181:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-07-14-24-21-e792f9e44a7ff4f3e43134fd937fa846.png"},7210:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-07-14-25-10-e1e530510a7073c92d28b0d29cec3a21.png"},9674:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-07-14-25-44-a03efffdefc976389129239af2af3052.png"},1734:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-07-14-26-49-5307fa1cf02880f26d439e56a07ba01c.png"},1082:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-07-14-38-23-d25b509aa6df3984c886107838f306b9.png"},9910:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-07-14-38-56-156fdf0974783ad2f3ce705530957586.png"},4445:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-07-14-39-23-3c17d57e8ee645c5912896f0e2b78bc4.png"},5659:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-07-14-41-27-ce8b1045e0621e6510109c60ce03ff7c.png"},4421:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-07-14-41-54-d66ee3010c25d62d4d224192e410b3a3.png"},5785:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-07-14-42-46-aed480fb66c136d5d41d18204f0f6d00.png"},6580:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-07-14-44-10-f7c22a5593619e32d0219a714e2c5849.png"},1139:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-07-15-16-23-5ac0948fdfc243b8d2c127d38dbb9ffb.png"},5781:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-10-04-34-15-ed1a51aa98f99d69dc6a881ebe211405.png"},3664:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-10-04-34-47-f8a205ab58f4d95965e873773f7fbef6.png"},3634:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-10-04-35-47-9d83dd50ac452b14e26f6d02b41d9b34.png"},6141:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-10-04-36-45-8aee2312b9f4a3ff9126289f6e085e26.png"},8039:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-10-04-41-19-e99c75b2771c3df7817b5c081dd0a4b9.png"},2133:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-01-10-04-42-08-4900a877f2a3bf1c1b79429c9ad57702.png"}}]);
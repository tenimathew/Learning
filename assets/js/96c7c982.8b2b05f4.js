"use strict";(self.webpackChunklearning=self.webpackChunklearning||[]).push([[1474],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>_});var a=n(7294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var o=a.createContext({}),m=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=m(e.components);return a.createElement(o.Provider,{value:t},e.children)},E={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,r=e.originalType,o=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=m(n),_=l,u=d["".concat(o,".").concat(_)]||d[_]||E[_]||r;return n?a.createElement(u,i(i({ref:t},p),{},{components:n})):a.createElement(u,i({ref:t},p))}));function _(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=n.length,i=new Array(r);i[0]=d;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s.mdxType="string"==typeof e?e:l,i[1]=s;for(var m=2;m<r;m++)i[m]=n[m];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},5119:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>i,default:()=>E,frontMatter:()=>r,metadata:()=>s,toc:()=>m});var a=n(7462),l=(n(7294),n(3905));const r={id:"Section 21. PLSQL",sidebar_position:21,description:"PLSQL"},i=void 0,s={unversionedId:"oracle/Section 21. PLSQL",id:"oracle/Section 21. PLSQL",title:"Section 21. PLSQL",description:"PLSQL",source:"@site/docs/oracle/21_plsql.md",sourceDirName:"oracle",slug:"/oracle/Section 21. PLSQL",permalink:"/learning/docs/oracle/Section 21. PLSQL",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/oracle/21_plsql.md",tags:[],version:"current",sidebarPosition:21,frontMatter:{id:"Section 21. PLSQL",sidebar_position:21,description:"PLSQL"},sidebar:"tutorialSidebar",previous:{title:"Section 20. Query Tuning",permalink:"/learning/docs/oracle/Section 20. Query Tuning"},next:{title:"Section 22. Conditional control",permalink:"/learning/docs/oracle/Section 22. Conditional control"}},o={},m=[{value:"Procedure Oriented vs Object Oriented",id:"procedure-oriented-vs-object-oriented",level:2},{value:"What is PL/SQL?",id:"what-is-plsql",level:2},{value:"Advantages of PLSQL",id:"advantages-of-plsql",level:2},{value:"PL/SQL Blocks",id:"plsql-blocks",level:2},{value:"Anonymous Block",id:"anonymous-block",level:3},{value:"Named Block",id:"named-block",level:3},{value:"Early vs. Late Binding",id:"early-vs-late-binding",level:2},{value:"PL/SQL data types",id:"plsql-data-types",level:2},{value:"Scalar data type",id:"scalar-data-type",level:3},{value:"Numeric data types",id:"numeric-data-types",level:3},{value:"Boolean data type",id:"boolean-data-type",level:3},{value:"Character data types",id:"character-data-types",level:3},{value:"RAW Datatype",id:"raw-datatype",level:4},{value:"Datetime data types",id:"datetime-data-types",level:3},{value:"Data type synonyms",id:"data-type-synonyms",level:3},{value:"CONSTANT, DEFAULT, NOT NULL",id:"constant-default-not-null",level:3},{value:"Host/Bind/Session Variable",id:"hostbindsession-variable",level:2},{value:"Anchored Data type/ Inheriting data type",id:"anchored-data-type-inheriting-data-type",level:2},{value:"Naming Conventions",id:"naming-conventions",level:2},{value:"Execute Immediate (Native Dynamic)",id:"execute-immediate-native-dynamic",level:2},{value:"Single Row Queries",id:"single-row-queries",level:3},{value:"DDL Operations",id:"ddl-operations",level:3},{value:"PL/SQL Block using EXECUTE IMMEDIATE",id:"plsql-block-using-execute-immediate",level:3},{value:"OPEN - FOR FETCH statement",id:"open---for-fetch-statement",level:3},{value:"Bind Variable",id:"bind-variable",level:3},{value:"BULK COLLECT INTO with EXECUTE IMMEDIATE",id:"bulk-collect-into-with-execute-immediate",level:3},{value:"UTL_MAIL",id:"utl_mail",level:2},{value:"UTL_FILE",id:"utl_file",level:2},{value:"External tables",id:"external-tables",level:2},{value:"Import data from Excel to Oracle using SQL Developer",id:"import-data-from-excel-to-oracle-using-sql-developer",level:2},{value:"XMLELEMENT",id:"xmlelement",level:2},{value:"SQL Loader",id:"sql-loader",level:2},{value:"Local Screening",id:"local-screening",level:2},{value:"Wrapped",id:"wrapped",level:2},{value:"DBMS Packages",id:"dbms-packages",level:2},{value:"Table Clusters",id:"table-clusters",level:2},{value:"Debugging",id:"debugging",level:2}],p={toc:m};function E(e){let{components:t,...n}=e;return(0,l.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h2",{id:"procedure-oriented-vs-object-oriented"},"Procedure Oriented vs Object Oriented"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"On the basis of"),(0,l.kt)("th",{parentName:"tr",align:null},"Procedure Oriented"),(0,l.kt)("th",{parentName:"tr",align:null},"Object Oriented"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Definition"),(0,l.kt)("td",{parentName:"tr",align:null},"It is a programming paradigm that is based on subroutines or procedure calls"),(0,l.kt)("td",{parentName:"tr",align:null},"It is a programming paradigm that is based on concept of objects")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Security"),(0,l.kt)("td",{parentName:"tr",align:null},"It is less secure than OOPS"),(0,l.kt)("td",{parentName:"tr",align:null},"Data hiding is possible in OOPs; hence it is more secure than POP")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Approach"),(0,l.kt)("td",{parentName:"tr",align:null},"It follows top-down approach"),(0,l.kt)("td",{parentName:"tr",align:null},"It follows bottom-up approach")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Access Modifiers"),(0,l.kt)("td",{parentName:"tr",align:null},"No access modifiers"),(0,l.kt)("td",{parentName:"tr",align:null},"Access modifiers in OOPs are PRIVATE, PUBLIC and PROTECTED")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Features"),(0,l.kt)("td",{parentName:"tr",align:null},"Modularity Predefined functions"),(0,l.kt)("td",{parentName:"tr",align:null},"- Inheritance")))),(0,l.kt)("h2",{id:"what-is-plsql"},"What is PL/SQL?"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Procedural Language/ Standard Query Language."),(0,l.kt)("li",{parentName:"ul"},"It is a procedural server side programming language"),(0,l.kt)("li",{parentName:"ul"},"Used to bridge the gap of SQL being non-procedural."),(0,l.kt)("li",{parentName:"ul"},"Case-insensitive programming language.")),(0,l.kt)("h2",{id:"advantages-of-plsql"},"Advantages of PL\\SQL"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Tight integration with SQL"),(0,l.kt)("li",{parentName:"ul"},"Business logic can be directly implemented at database level hence reduce network latency"),(0,l.kt)("li",{parentName:"ul"},"High performance, High productivity"),(0,l.kt)("li",{parentName:"ul"},"Support object oriented programming")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\n    --Declaration statements\nBEGIN\n    --Executable statements\nEXCEPTION\n    --Exception handling statements\nEND;\n")),(0,l.kt)("h2",{id:"plsql-blocks"},"PL/SQL Blocks"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Blocks are basic programming units in PL/SQL programming language")),(0,l.kt)("h3",{id:"anonymous-block"},"Anonymous Block"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"As this block is created without a name, this block does not create any object in the database. Thus, the scope for reusability is zero. It compiles every time you execute.")),(0,l.kt)("h3",{id:"named-block"},"Named Block"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"It creates a database object. Complied for one time and stored for reuse.")),(0,l.kt)("h2",{id:"early-vs-late-binding"},"Early vs. Late Binding"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Late binding means code is compiled at execution. Early binding means code is compiled prior to execution.")),(0,l.kt)("h2",{id:"plsql-data-types"},"PL/SQL data types"),(0,l.kt)("p",null,"PL/SQL data types are divided into 4 types:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Scalar"),(0,l.kt)("li",{parentName:"ul"},"Reference"),(0,l.kt)("li",{parentName:"ul"},"Large Objects"),(0,l.kt)("li",{parentName:"ul"},"Composite")),(0,l.kt)("p",null,"PL/SQL divides the scalar data types into four families:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Number"),(0,l.kt)("li",{parentName:"ul"},"Boolean"),(0,l.kt)("li",{parentName:"ul"},"Character"),(0,l.kt)("li",{parentName:"ul"},"Datetime")),(0,l.kt)("h3",{id:"scalar-data-type"},"Scalar data type"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"A scalar data type may have subtypes."),(0,l.kt)("li",{parentName:"ul"},"A subtype is a data type that is a subset of another data type, which is its base type."),(0,l.kt)("li",{parentName:"ul"},"A subtype further defines a base type by restricting the value or size of the base data type.")),(0,l.kt)("p",null,"Note that PL/SQL scalar data types include SQL data types and its own data type such as Boolean."),(0,l.kt)("h3",{id:"numeric-data-types"},"Numeric data types"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The numeric data types represent real numbers, integers, and floating-point numbers. They are stored as ",(0,l.kt)("inlineCode",{parentName:"li"},"NUMBER"),", IEEE floating-point storage types (",(0,l.kt)("inlineCode",{parentName:"li"},"BINARY_FLOAT")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"BINARY_DOUBLE"),"), and ",(0,l.kt)("inlineCode",{parentName:"li"},"PLS_INTEGER"),"."),(0,l.kt)("li",{parentName:"ul"},"The data types ",(0,l.kt)("inlineCode",{parentName:"li"},"NUMBER"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"BINARY_FLOAT"),", and ",(0,l.kt)("inlineCode",{parentName:"li"},"BINARY_DOUBLE")," are SQL data types."),(0,l.kt)("li",{parentName:"ul"},"The ",(0,l.kt)("inlineCode",{parentName:"li"},"PLS_INTEGER")," datatype is specific to PL/SQL. It represents signed 32 bits integers that range from -2,147,483,648 to 2,147,483,647."),(0,l.kt)("li",{parentName:"ul"},"Because ",(0,l.kt)("inlineCode",{parentName:"li"},"PLS_INTEGER")," datatype uses hardware arithmetic, they are faster than ",(0,l.kt)("inlineCode",{parentName:"li"},"NUMBER")," operations, which uses software arithmetic."),(0,l.kt)("li",{parentName:"ul"},"In addition, ",(0,l.kt)("inlineCode",{parentName:"li"},"PLS_INTEGER")," values require less storage than ",(0,l.kt)("inlineCode",{parentName:"li"},"NUMBER"),". Hence, you should always use ",(0,l.kt)("inlineCode",{parentName:"li"},"PLS_INTEGER")," values for all calculation in its range to increase the efficiency of programs."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"PLS_INTEGER")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"BINARY_INTEGER")," data types are identical.")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"PLS_INTEGER")," datatype has the following predefined subtypes:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"PLS_INTEGER subtypes"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"NATURAL"),(0,l.kt)("td",{parentName:"tr",align:null},"Represents nonnegative PLS_INTEGER values")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"NATURALN"),(0,l.kt)("td",{parentName:"tr",align:null},"Represents nonnegative PLS_INTEGER values with NOT NULL constraint")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"POSITIVE"),(0,l.kt)("td",{parentName:"tr",align:null},"Represents positive PLS_INTEGER values")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"POSITIVEN"),(0,l.kt)("td",{parentName:"tr",align:null},"Represents positive PLS_INTEGER value with NOT NULL constraint")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SIGNTYPE"),(0,l.kt)("td",{parentName:"tr",align:null},"Represents three values -1, 0, or 1, which are useful for tri-state logic programming")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SIMPLE_INTEGER"),(0,l.kt)("td",{parentName:"tr",align:null},"Represents PLS_INTEGER values with NOT NULL constraint.")))),(0,l.kt)("h3",{id:"boolean-data-type"},"Boolean data type"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The ",(0,l.kt)("inlineCode",{parentName:"li"},"BOOLEAN")," datatype has three data values: ",(0,l.kt)("inlineCode",{parentName:"li"},"TRUE"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"FALSE"),", and ",(0,l.kt)("inlineCode",{parentName:"li"},"NULL"),"."),(0,l.kt)("li",{parentName:"ul"},"Boolean values are typically used in control flow structure such as ",(0,l.kt)("inlineCode",{parentName:"li"},"IF-THEN"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"CASE"),", and loop statements like ",(0,l.kt)("inlineCode",{parentName:"li"},"LOOP"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"FOR LOOP"),", and ",(0,l.kt)("inlineCode",{parentName:"li"},"WHILE LOOP"),"."),(0,l.kt)("li",{parentName:"ul"},"SQL does not have the ",(0,l.kt)("inlineCode",{parentName:"li"},"BOOLEAN")," data type, therefore, you cannot:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Assign a ",(0,l.kt)("inlineCode",{parentName:"li"},"BOOLEAN")," value to a table column."),(0,l.kt)("li",{parentName:"ul"},"Select the value from a table column into a ",(0,l.kt)("inlineCode",{parentName:"li"},"BOOLEAN")," variable."),(0,l.kt)("li",{parentName:"ul"},"Use a ",(0,l.kt)("inlineCode",{parentName:"li"},"BOOLEAN")," value in a SQL function."),(0,l.kt)("li",{parentName:"ul"},"Use a ",(0,l.kt)("inlineCode",{parentName:"li"},"BOOLEAN")," expression in a SQL statement."),(0,l.kt)("li",{parentName:"ul"},"Use a ",(0,l.kt)("inlineCode",{parentName:"li"},"BOOLEAN")," value in the ",(0,l.kt)("inlineCode",{parentName:"li"},"DBMS_OUTPUT.PUT_LINE")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"DBMS_OUTPUT.PUT")," subprograms.")))),(0,l.kt)("h3",{id:"character-data-types"},"Character data types"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The character data types represent alphanumeric text. PL/SQL uses the SQL character data types such as ",(0,l.kt)("inlineCode",{parentName:"li"},"CHAR"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"VARCHAR2"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"LONG"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"RAW"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"LONG RAW"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"ROWID"),", and ",(0,l.kt)("inlineCode",{parentName:"li"},"UROWID"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"CHAR(n)")," is a fixed-length character type whose length is from 1 to 32,767 bytes."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"VARCHAR2(n)")," is varying length character data from 1 to 32,767 bytes.")),(0,l.kt)("h4",{id:"raw-datatype"},"RAW Datatype"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"In Oracle PL/SQL, RAW is a data type used to store binary data, or data which is byte oriented (for example, graphics or audio files). One of the most important things to note about RAW data is that it can only be queried or inserted; RAW data cannot be manipulated. RAW data is always returned as a hexadecimal character value")),(0,l.kt)("h3",{id:"datetime-data-types"},"Datetime data types"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The datetime data types represent dates, timestamp with or without time zone and intervals."),(0,l.kt)("li",{parentName:"ul"},"PL/SQL datetime data types are ",(0,l.kt)("inlineCode",{parentName:"li"},"DATE"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"TIMESTAMP"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"TIMESTAMP WITH TIME ZONE"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"TIMESTAMP WITH LOCAL TIME ZONE"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"INTERVAL YEAR TO MONTH"),", and ",(0,l.kt)("inlineCode",{parentName:"li"},"INTERVAL DAY TO SECOND"),".")),(0,l.kt)("h3",{id:"data-type-synonyms"},"Data type synonyms"),(0,l.kt)("p",null,"Data types have synonyms for compartibility with non-Oracle data sources such as IBM Db2, SQL Server. And it is not a good practice to use data type synonym unless you are accessing a non-Oracle Database."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Data Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Synonyms"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"NUMBER"),(0,l.kt)("td",{parentName:"tr",align:null},"DEC, DECIMAL, DOUBLE PRECISION, FLOAT, INTEGER, INT, NUMERIC, REAL, SMALLINT")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"CHAR"),(0,l.kt)("td",{parentName:"tr",align:null},"CHARACTER, STRING")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"VARCHAR2"),(0,l.kt)("td",{parentName:"tr",align:null},"VARCHAR")))),(0,l.kt)("h3",{id:"constant-default-not-null"},"CONSTANT, DEFAULT, NOT NULL"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SET SERVEROUTPUT ON;\n\nDECLARE\n    V_PI CONSTANT NUMBER(7,6):=3.14; --Assigning is mandatory\n    V_NAME VARCHAR2(20) DEFAULT 'Unknown'; --Assigning is mandatory\n    V_AGE NUMBER NOT NULL :=50; --Assigning is mandatory\nBEGIN\n    DBMS_OUTPUT.PUT_LINE('v_pi:' ||V_PI);\n    DBMS_OUTPUT.PUT_LINE('v_name:'||V_NAME);\n    DBMS_OUTPUT.PUT_LINE('v_age:'||V_AGE);\nEND;\n")),(0,l.kt)("h2",{id:"hostbindsession-variable"},"Host/Bind/Session Variable"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"It is a variable of the interface. This variable can be bonded with SQL or PL\\SQL anonymous block. The scope of these variables is till the end of the session. These variables always preceded with a colon (:).")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"VARIABLE v_bind1 VARCHAR2(25); --Not PL/SQL statement\n\nDECLARE\nBEGIN\n    :v_bind1 := 'Binding 1';\n    DBMS_OUTPUT.PUT_LINE(:v_bind1);\nEND;\n--Not PL/SQL statements--\nVARIABLE v_bind2 VARCHAR2(25);\nVARIABLE v_bind3 VARCHAR2(25);\nEXECUTE :v_bind2 := 'Binding 2'; --SQL*Plus command\nEXECUTE :v_bind3 := 'Binding 3';\nPRINT :v_bind2;\nPRINT; --Displays all bind variable values in the session\n----\nSET AUTOPRINT ON --To turn on automatic printing of bind variable while assigning\n")),(0,l.kt)("h2",{id:"anchored-data-type-inheriting-data-type"},"Anchored Data type/ Inheriting data type"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"It is used to pick up data type and size from a previously declared object into a new variable. Advantage of this is, when you change the data type or size of the field in the table, it will also affect this variable. So there is less maintenance.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"VNAME EMP.ENAME%TYPE;\nVEMP EMP%ROWTYPE; -- Record datatype variable\n")),(0,l.kt)("h2",{id:"naming-conventions"},"Naming Conventions"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null}),(0,l.kt)("th",{parentName:"tr",align:null}))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Package - PKG","_"),(0,l.kt)("td",{parentName:"tr",align:null},"Local Variable - LV","_")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Procedure - PRC","_"),(0,l.kt)("td",{parentName:"tr",align:null},"Global Variable - GV","_")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Function - FNC","_"),(0,l.kt)("td",{parentName:"tr",align:null},"Cursor - C","_"," or CUR","_")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Constants - C","_"),(0,l.kt)("td",{parentName:"tr",align:null},"Bind variable - B","_")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Exception - E","_"),(0,l.kt)("td",{parentName:"tr",align:null},"Object - ","_","OBJ")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Parameter - P","_"),(0,l.kt)("td",{parentName:"tr",align:null},"Collections - ","_","TAB")))),(0,l.kt)("h2",{id:"execute-immediate-native-dynamic"},"Execute Immediate (Native Dynamic)"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Using Execute Immediate, we can parse and execute any SQL statement or a PL/SQL block dynamically in Oracle database"),(0,l.kt)("li",{parentName:"ul"},"Use of bind variable: Security against SQL injections and performance enhancement by reducing hard parsing."),(0,l.kt)("li",{parentName:"ul"},"Generally dynamic SQL is slower than static SQL so it should not be used unless absolutely necessary."),(0,l.kt)("li",{parentName:"ul"},"It is faster than DBMS_SQL"),(0,l.kt)("li",{parentName:"ul"},"Why to use DBMS_SQL?",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"When the dynamic SQL statement has unknown number of bind variables or columns until runtime"),(0,l.kt)("li",{parentName:"ul"},"When we need tp execute same SQL statement multiple times with different bind variables. (To avoid parsing)"))),(0,l.kt)("li",{parentName:"ul"},"Main advantage of dynamic SQL is that it allows to perform DDL commands that are not supported directly within PL/SQL")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"BEGIN\n    EXECUTE IMMEDIATE 'GRANT SELECT ON EMPLOYEES TO SYS';\nEND;\n/\nBEGIN\n    EXECUTE IMMEDIATE 'GRANT SELECT ON EMPLOYEES TO SYS;';\nEND;\n/\nCREATE OR REPLACE PROCEDURE prc_create_table_dynamic\n    (p_table_name IN VARCHAR2, p_col_specs IN VARCHAR2) IS\nBEGIN\n    EXECUTE IMMEDIATE 'CREATE TABLE '||p_table_name||' ('||p_col_specs||')';\nEND;\n/\nEXEC prc_create_table_dynamic('dynamic_temp_table', 'id NUMBER PRIMARY KEY, name VARCHAR2(100)');\n/\nSELECT * FROM dynamic_temp_table;\n/\nCREATE OR REPLACE PROCEDURE prc_generic (p_dynamic_sql IN VARCHAR2) IS\nBEGIN\n    EXECUTE IMMEDIATE p_dynamic_sql;\nEND;\n/\nEXEC prc_generic('drop table dynamic_temp_table');\n/\nEXEC prc_generic('drop procedure PRC_CREATE_TABLE_DYNAMIC');\n/\nDROP PROCEDURE prc_generic;\n\n")),(0,l.kt)("h3",{id:"single-row-queries"},"Single Row Queries"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\n    l_sql VARCHAR2(100);\n    l_ename emp.ename%TYPE;\nBEGIN\n    l_sql:='SELECT ename FROM emp WHERE emp_no=1234';\n    EXECUTE IMMEDIATE l_sql INTO l_ename;\nEND;\n\n--------USING CLAUSE\n\nREATE TABLE names (ID NUMBER PRIMARY KEY, NAME VARCHAR2(100));\n/\nCREATE OR REPLACE FUNCTION insert_values (ID IN VARCHAR2, NAME IN VARCHAR2) RETURN PLS_INTEGER IS\nBEGIN\n    EXECUTE IMMEDIATE 'INSERT INTO names VALUES(:a, :b)' USING ID,NAME;\n    RETURN SQL%rowcount;\nEND;\n/\nSET SERVEROUTPUT ON;\nDECLARE\n    v_affected_rows PLS_INTEGER;\nBEGIN\n    v_affected_rows := insert_values(2,'John');\n    dbms_output.put_line(v_affected_rows|| ' row inserted!');\nEND;\n/\nSELECT * FROM names;\n/\nALTER TABLE names ADD (last_name VARCHAR2(100));\n/\nCREATE OR REPLACE FUNCTION update_names (ID IN VARCHAR2, last_name IN VARCHAR2) RETURN PLS_INTEGER IS\n    v_dynamic_sql VARCHAR2(200);\nBEGIN\n    v_dynamic_sql := 'UPDATE names SET last_name = :1 WHERE id = :2' ;\n    EXECUTE IMMEDIATE v_dynamic_sql USING last_name, ID;\n    RETURN SQL%rowcount;\nEND;\n/\nDECLARE\n    v_affected_rows PLS_INTEGER;\nBEGIN\n    v_affected_rows := update_names(2,'Brown');\n    dbms_output.put_line(v_affected_rows|| ' row updated!');\nEND;\n/\nCREATE OR REPLACE FUNCTION update_names (ID IN VARCHAR2, last_name IN OUT VARCHAR2) RETURN PLS_INTEGER IS\n    v_dynamic_sql VARCHAR2(200);\nBEGIN\n    v_dynamic_sql := 'UPDATE names SET last_name = :1 WHERE id = :2' ;\n    EXECUTE IMMEDIATE v_dynamic_sql USING IN OUT last_name, ID;\n    RETURN SQL%rowcount;\nEND;\n/\nCREATE OR REPLACE FUNCTION update_names (ID IN VARCHAR2, last_name IN VARCHAR2, first_name OUT VARCHAR2) RETURN PLS_INTEGER IS\n    v_dynamic_sql VARCHAR2(200);\nBEGIN\n    v_dynamic_sql := 'UPDATE names SET last_name = :1 WHERE id = :2 :3' ;\n    EXECUTE IMMEDIATE v_dynamic_sql USING last_name, ID, OUT first_name;\n    RETURN SQL%rowcount;\nEND;\n/\nDECLARE\n    v_affected_rows PLS_INTEGER;\n    v_first_name VARCHAR2(100);\nBEGIN\n    v_affected_rows := update_names(2,'KING',v_first_name);\n    dbms_output.put_line(v_affected_rows|| ' row updated!');\n    dbms_output.put_line(v_first_name);\nEND;\n/\nCREATE OR REPLACE FUNCTION update_names (ID IN VARCHAR2, last_name IN VARCHAR2, first_name OUT VARCHAR2) RETURN PLS_INTEGER IS\n    v_dynamic_sql VARCHAR2(200);\nBEGIN\n    v_dynamic_sql := 'UPDATE names SET last_name = :1 WHERE id = :2 RETURNING name INTO :3' ;\n    EXECUTE IMMEDIATE v_dynamic_sql USING last_name, ID RETURNING INTO first_name;\n    RETURN SQL%rowcount;\nEND;\n/\nDROP TABLE names;\nDROP FUNCTION insert_values;\nDROP FUNCTION update_names;\n\n---------USING INTO CLAUSE\nCREATE OR REPLACE FUNCTION get_count (table_name IN VARCHAR2) RETURN PLS_INTEGER IS\n    v_count PLS_INTEGER;\nBEGIN\n    EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM ' || table_name INTO v_count;\n    RETURN v_count;\nEND;\n/\nSET SERVEROUTPUT ON;\nBEGIN\n    dbms_output.put_line('There are '||get_count('employees')||' rows in the employees table!');\nEND;\n/\nDECLARE\n    v_table_name VARCHAR2(50);\nBEGIN\n    FOR r_table IN (SELECT table_name FROM user_tables) LOOP\n        dbms_output.put_line('There are '||get_count(r_table.table_name)||' rows in the '||r_table.table_name||' table!');\n    END LOOP;\nEND;\n/\nDECLARE\n    v_table_name VARCHAR2(50);\nBEGIN\n    FOR r_table IN (SELECT table_name FROM user_tables) LOOP\n        IF get_count(r_table.table_name) > 100 THEN\n            dbms_output.put_line('There are '||get_count(r_table.table_name)||' rows in the '||r_table.table_name||' table!');\n            dbms_output.put_line('It should be considered for partitioning');\n        END IF;\n    END LOOP;\nEND;\n/\n\nCREATE TABLE stock_managers AS SELECT * FROM employees WHERE job_id = 'ST_MAN';\n/\nCREATE TABLE stock_clerks AS SELECT * FROM employees WHERE job_id = 'ST_CLERK';\n/\nCREATE OR REPLACE FUNCTION get_avg_sals (p_table IN VARCHAR2, p_dept_id IN NUMBER) RETURN PLS_INTEGER IS\n    v_average PLS_INTEGER;\nBEGIN\n    EXECUTE IMMEDIATE 'SELECT AVG(salary) FROM :1 WHERE department_id = :2' INTO v_average USING p_table, p_dept_id;\n    RETURN v_average;\nEND;\n/\nSELECT get_avg_sals('stock_clerks','50') FROM dual;\n/\nCREATE OR REPLACE FUNCTION get_avg_sals (p_table IN VARCHAR2, p_dept_id IN NUMBER) RETURN PLS_INTEGER IS\n    v_average PLS_INTEGER;\nBEGIN\n    EXECUTE IMMEDIATE 'SELECT AVG(salary) FROM '||p_table||' WHERE department_id = :2' INTO v_average USING p_dept_id;\n    RETURN v_average;\nEND;\n/\nSELECT get_avg_sals('stock_managers','50') FROM dual;\n/\nDROP FUNCTION get_count;\nDROP FUNCTION get_avg_sals;\nDROP TABLE stock_clerks;\nDROP TABLE stock_managers;\n\n---------USING BULK COLLECT INTO\n\nDECLARE\n   TYPE t_name IS TABLE OF VARCHAR2(20);\n   names   t_name;\nBEGIN\n    EXECUTE IMMEDIATE 'SELECT distinct first_name FROM employees'\n        BULK COLLECT INTO names;\n    FOR i IN 1..names.COUNT LOOP\n        dbms_output.put_line(names(i));\n    END LOOP;\nEND;\n/\nCREATE TABLE employees_copy AS SELECT * FROM employees;\n/\nDECLARE\n   TYPE t_name IS TABLE OF VARCHAR2(20);\n   names   t_name;\nBEGIN\n    EXECUTE IMMEDIATE 'UPDATE employees_copy SET salary = salary + 1000 WHERE department_id = 30 RETURNING first_name INTO :a'\n        RETURNING BULK COLLECT INTO names;\n    FOR i IN 1..names.COUNT LOOP\n        dbms_output.put_line(names(i));\n    END LOOP;\nEND;\n/\nDROP TABLE employees_copy;\n\n")),(0,l.kt)("h3",{id:"ddl-operations"},"DDL Operations"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"BEGIN\n    EXECUTE IMMEDIATE 'TRUNCATE TABLE my_table';\nEND;\n")),(0,l.kt)("h3",{id:"plsql-block-using-execute-immediate"},"PL/SQL Block using EXECUTE IMMEDIATE"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\n    plsql_blk VARCHAR2(400);\nBEGIN\n    plsql_blk := 'DECLARE\n            var_user VARCHAR2(10);\n        BEGIN\n            SELECT user INTO var_user FROM DUAL;\n            DBMS_OUTPUT.PUT_LINE(''User:'' || var_user);\n        END;';\n    EXECUTE IMMEDIATE plsql_blk;\nEND;\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"BEGIN\n    FOR r_emp in (SELECT * FROM employees) LOOP\n        dbms_output.put_line(r_emp.first_name||' '||r_emp.last_name);\n    END LOOP;\nEND;\n/\nDECLARE\n    v_dynamic_text varchar2(1000);\nBEGIN\n    v_dynamic_text := q'[BEGIN\n    FOR r_emp in (SELECT * FROM employees) LOOP\n        dbms_output.put_line(r_emp.first_name||' '||r_emp.last_name);\n    END LOOP;\n    END;]';\n    EXECUTE IMMEDIATE v_dynamic_text;\nEND;\n/\nDECLARE\n    v_dynamic_text VARCHAR2(1000);\n    v_department_id PLS_INTEGER := 30;\nBEGIN\n    v_dynamic_text := q'[BEGIN\n    FOR r_emp in (SELECT * FROM employees WHERE department_id = v_department_id) LOOP\n        dbms_output.put_line(r_emp.first_name||' '||r_emp.last_name);\n    END LOOP;\n    END;]';\n    EXECUTE IMMEDIATE v_dynamic_text;\nEND;\n/\nDECLARE\n    v_dynamic_text VARCHAR2(1000);\n    --v_department_id pls_integer := 30;\nBEGIN\n    v_dynamic_text := q'[DECLARE\n    v_department_id pls_integer := 30;\n    BEGIN\n    FOR r_emp in (SELECT * FROM employees WHERE department_id = v_department_id) LOOP\n        dbms_output.put_line(r_emp.first_name||' '||r_emp.last_name);\n    END LOOP;\n    END;]';\n    EXECUTE IMMEDIATE v_dynamic_text;\nEND;\n/\nCREATE OR REPLACE PACKAGE pkg_temp AS\nv_department_id_pkg PLS_INTEGER := 50;\nEND;\n/\nDECLARE\n    v_dynamic_text VARCHAR2(1000);\n    --v_department_id pls_integer := 30;\nBEGIN\n    v_dynamic_text := q'[BEGIN\n    FOR r_emp in (SELECT * FROM employees WHERE department_id = pkg_temp.v_department_id_pkg) LOOP\n        dbms_output.put_line(r_emp.first_name||' '||r_emp.last_name);\n    END LOOP;\n    END;]';\n    EXECUTE IMMEDIATE v_dynamic_text;\nEND;\n/\nDECLARE\n    v_dynamic_text VARCHAR2(1000);\n    v_department_id PLS_INTEGER := 30;\nBEGIN\n    v_dynamic_text := q'[BEGIN\n    FOR r_emp in (SELECT * FROM employees WHERE department_id = :1) LOOP\n        dbms_output.put_line(r_emp.first_name||' '||r_emp.last_name);\n    END LOOP;\n    END;]';\n    EXECUTE IMMEDIATE v_dynamic_text USING v_department_id;\nEND;\n/\nDECLARE\n    v_dynamic_text VARCHAR2(1000);\n    v_department_id PLS_INTEGER := 30;\n    v_max_salary PLS_INTEGER := 0;\nBEGIN\n    v_dynamic_text := q'[BEGIN\n    FOR r_emp in (SELECT * FROM employees WHERE department_id = :1) LOOP\n        dbms_output.put_line(r_emp.first_name||' '||r_emp.last_name);\n        if r_emp.salary > :sal then\n            :sal := r_emp.salary;\n        end if;\n    END LOOP;\n    END;]';\n    EXECUTE IMMEDIATE v_dynamic_text USING v_department_id, IN OUT v_max_salary;\n    dbms_output.put_line('The maximum salary of this department is : '||v_max_salary);\nEND;\n/\nDECLARE\n    v_dynamic_text VARCHAR2(1000);\n    v_department_id PLS_INTEGER := 30;\n    v_max_salary PLS_INTEGER := 0;\nBEGIN\n    v_dynamic_text := q'[BEGIN\n    FOR r_emp in (SELECT * FROM employeese WHERE department_id = :1) LOOP\n        dbms_output.put_line(r_emp.first_name||' '||r_emp.last_name);\n        if r_emp.salary > :sal then\n            :sal := r_emp.salary;\n        end if;\n    END LOOP;\n    END;]';\n    EXECUTE IMMEDIATE v_dynamic_text USING v_department_id, IN OUT v_max_salary;\n    dbms_output.put_line('The maximum salary of this department is : '||v_max_salary);\nEXCEPTION\n    WHEN OTHERS THEN\n    dbms_output.put_line('The error is : '||sqlerrm);\nEND;\n/\nDECLARE\n    v_dynamic_text VARCHAR2(1000);\n    v_department_id PLS_INTEGER := 30;\n    v_max_salary PLS_INTEGER := 0;\nBEGIN\n    v_dynamic_text := q'[BEGIN\n    FOR r_emp in (SELECT * FROM employeese WHERE department_id = :1) LOOP\n        dbms_output.put_line(r_emp.first_name||' '||r_emp.last_name);\n        if r_emp.salary > :sal then\n            :sal := r_emp.salary;\n        end if;\n    END LOOP;\n    EXCEPTION\n    WHEN OTHERS THEN\n    dbms_output.put_line('The error is : '||SQLERRM);\n    END;]';\n    EXECUTE IMMEDIATE v_dynamic_text USING v_department_id, IN OUT v_max_salary;\n    dbms_output.put_line('The maximum salary of this department is : '||v_max_salary);\nEND;\n/\nDROP PACKAGE pkg_temp;\n")),(0,l.kt)("h3",{id:"open---for-fetch-statement"},"OPEN - FOR FETCH statement"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\n  TYPE emp_cur_type  IS REF CURSOR;\n  emp_cursor      emp_cur_type;\n  emp_record      employees%rowtype;\nBEGIN\n  OPEN emp_cursor FOR 'SELECT * FROM employees WHERE job_id = ''IT_PROG'''; -- This performs poorly as it does not store the query in SGA as every query will be different\n    FETCH emp_cursor INTO emp_record;\n    dbms_output.put_line(emp_record.first_name||emp_record.last_name);\n  CLOSE emp_cursor;\nEND;\n/\nDECLARE\n  TYPE emp_cur_type  IS REF CURSOR;\n  emp_cursor      emp_cur_type;\n  emp_record      employees%rowtype;\nBEGIN\n  OPEN emp_cursor FOR 'SELECT * FROM employees WHERE job_id = :job' USING 'IT_PROG'; -- This performs better than before. So use USING keyword. Here, the query may be used for cursor sharing.\n    FETCH emp_cursor INTO emp_record;\n    dbms_output.put_line(emp_record.first_name||emp_record.last_name);\n  CLOSE emp_cursor;\nEND;\n/\nDECLARE\n  TYPE emp_cur_type  IS REF CURSOR;\n  emp_cursor      emp_cur_type;\n  emp_record      employees%rowtype;\nBEGIN\n  OPEN emp_cursor FOR 'SELECT * FROM employees WHERE job_id = :job' USING 'IT_PROG';\n  LOOP\n    FETCH emp_cursor INTO emp_record;\n    EXIT WHEN emp_cursor%notfound;\n    dbms_output.put_line(emp_record.first_name||emp_record.last_name);\n  END LOOP;\n  CLOSE emp_cursor;\nEND;\n/\nDECLARE\n  TYPE emp_cur_type  IS REF CURSOR;\n  emp_cursor      emp_cur_type;\n  emp_record      employees%rowtype;\n  v_table_name    VARCHAR(20);\nBEGIN\n  v_table_name := 'employees';\n  OPEN emp_cursor FOR 'SELECT * FROM '||v_table_name||' WHERE job_id = :job' USING 'IT_PROG';\n  LOOP\n    FETCH emp_cursor INTO emp_record;\n    EXIT WHEN emp_cursor%notfound;\n    dbms_output.put_line(emp_record.first_name||emp_record.last_name);\n  END LOOP;\n  CLOSE emp_cursor;\nEND;\n")),(0,l.kt)("h3",{id:"bind-variable"},"Bind Variable"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\n    l_sql VARCHAR2(100);\n    l_ename employees.first_name%TYPE;\nBEGIN\n    l_sql := 'SELECT first_name FROM employees WHERE employee_id = :empno and department_id = :deptno'; --:empno is a bind variable\n    EXECUTE IMMEDIATE l_sql INTO l_ename USING 100,90;--passing 100 into empno and 90 into deptno as bind variable\n    DBMS_OUTPUT.PUT_LINE(l_ename);\nEND;\n")),(0,l.kt)("h3",{id:"bulk-collect-into-with-execute-immediate"},"BULK COLLECT INTO with EXECUTE IMMEDIATE"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\n    TYPE nt_Fname IS TABLE OF VARCHAR2(60);\n    fname nt_Fname;\n    sql_qry VARCHAR2(150);\nBEGIN\n    sql_qry := 'SELECT first_name FROM employees';\n    EXECUTE IMMEDIATE sql_qry BULK COLLECT INTO fname;\nEND;\n")),(0,l.kt)("h2",{id:"utl_mail"},"UTL_MAIL"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The ",(0,l.kt)("inlineCode",{parentName:"p"},"UTL_MAIL")," package was introduced in Oracle 10g to provide a simple API to allow email to be sent from PL/SQL.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The UTL_MAIL package is used to send emails that include commonly used email features.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"There are some other packages that can be used to send emails such as UTL_TCP, UTL_SMTP, APEX_MAIL...")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The UTL_MAIL package is very easy to use.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"To use UTL_MAIL, you need a SMTP server")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The UTL_MAIL package is not installed by default. You need to install it.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Here are the steps to install & configure the UTL_MAIL package."),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Execute below files that are available in oracle home directory"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"? will try to automatically find oracle home directory\n@?\\rdbms\\admin\\ut1_mail.sql\n@?\\rdbms\\admin\\prvtmail.plb"),(0,l.kt)("li",{parentName:"ul"},"or you can specify the path variable\n@ORACLE_HOME\\rdbms\\admin\\utlmail.sq1\n@ORACLE_HOME\\rdbms\\admin\\prvtmail.plb"),(0,l.kt)("li",{parentName:"ul"},"or you can specify entire path\n@C:\\OracleApp\\WINDOWS.X64_193000_db_home\\rdbms\\admin\\uti_mail.sql\n@C:\\OracleApp\\WINDOWS.X64_193000_db_home\\rdbms\\admin\\prvtmail.plb"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"You can check for SMTP server name using below query or add IP/port of SMTP server"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM v$parameter WHERE name = 'smtp_out_server';\nALTER SYSTEM SET smtp_out_server = 'your_smtp_server';\n"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Configuring Network Security: Creating ACL(Access Control List) and granting privilege to the user."),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"BEGIN\n    DBMS_NETWORK_ACL_ADMIN.CREATE_ACL (\n        acl => 'mail-server.xml',\n        description => 'Granting privs to required users for UTL_SMTP.xmI'\n        principal => 'YOUR_USER',\n        is_grant  => TRUE,\n        privilege => 'connect');\n\n    DBMS_NETWORK_ACL_ADMIN.ADD_PRIVILEGE (\n        acl =\u203a 'mail-server.xmI',\n        principal => 'YOUR_USER',\n        is_grant => TRUE,\n        privilege =\u203a 'resolve');\n\n    DBMS_NETWORK_ACL_ADMIN.ASSIGN_ACL (\n        acl =\u203a 'mail-server.xm]',\n        host =\u203a 'the smtp server');\nEND;\nCOMMIT;\n")))))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"--Sending an email with the least number of parameters\nBEGIN\n    UTL_MAIL.send(\n                  sender     => 'somebody@somedomain.com',\n                  recipients => 'oraclemaster@outlook.com',\n                  subject    => 'Example 1: Test Email Subject',\n                  message    => 'This is a test email from someone.'\n                 );\nEND;\n/\n--Sending an email with specific names to the sender and recipients\nBEGIN\n    UTL_MAIL.send(\n                  sender     => 'Some Person <somebody@somedomain.com>',\n                  recipients => 'Oracle Masters <oraclemaster@outlook.com>',\n                  subject    => 'Example 2: Test Email Subject',\n                  message    => 'This is a test email from someone.'\n                 );\nEND;\n/\n--Sending an email with using all of the parameters\nBEGIN\n    UTL_MAIL.send(\n                  sender     => 'somebody@somedomain.com',\n                  recipients => 'oraclemaster@outlook.com',\n                  cc         => 'somemanager@somedomain.something,someotherperson@somedomain.something',\n                  bcc        => 'someothermanager@somedomain.com',\n                  subject    => 'Example 3: Test Email Subject',\n                  message    => 'This is a test email from someone.',\n                  mime_type  => 'text/plain; charset=us-ascii',\n                  priority   => 1, -- 1 to 5; 1 highest 5 lowest ; default -3\n                  replyto    => 'somereplyaddress@somedomain.com'\n                 );\nEND;\n/\n--Sending an email by dynamically filling the message body\nDECLARE\n    cursor cur_top_earning_emps is\n                    select employee_id, first_name, last_name, salary\n                    from hr.employees\n                    where salary > 10000\n                    order by salary desc;\n    v_message varchar2(32767); -- If you need to send CLOB data, you can use UTL_SMTP package\nBEGIN\n    v_message := 'EMPLOYEE ID'||CHR(9)||'FIRST NAME'||CHR(9)||'LAST NAME'||CHR(9)||'EMPLOYEE ID'||CHR(13);\n    for r_top in cur_top_earning_emps loop\n        v_message := v_message||r_top.employee_id||CHR(9)||r_top.first_name||CHR(9)||r_top.last_name||CHR(9)||r_top.salary||CHR(13);\n    end loop;\n\n    UTL_MAIL.send(\n                  sender     => 'topearnings@somedns.com',\n                  recipients => 'oraclemaster@outlook.com',\n                  subject    => 'Example 4: The Employees Earning More Than $10000',\n                  message    => v_message\n                 );\nEND;\n/\n--Sending an HTTP mail\nDECLARE\n    cursor cur_top_earning_emps is\n                    select employee_id, first_name, last_name, salary\n                    from hr.employees\n                    where salary > 10000\n                    order by salary desc;\n    v_message varchar2(32767);\nBEGIN\n    v_message := '<!DOCTYPE html>\n                    <html>\n                       <head>\n                          <meta charset=''Cp1252''>\n                          <title>Top Earning Employees</title>\n                          <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n                          <style>\n                             * {\n                             margin: 0;\n                             padding: 0;\n                             }\n                             body {\n                             font: 14px/1.4 Georgia, Serif;\n                             }\n                             /*\n                             Generic Styling, for Desktops/Laptops\n                             */\n                             table {\n                             width: 100%;\n                             border-collapse: collapse;\n                             }\n                             /* Zebra striping */\n                             tr:nth-of-type(odd) {\n                             background: #eee;\n                             }\n                             th {\n                             background: #333;\n                             color: white;\n                             font-weight: bold;\n                             }\n                             td, th {\n                             padding: 6px;\n                             border: 1px solid #9B9B9B;\n                             text-align: left;\n                             }\n                             @media\n                             only screen and (max-width: 760px),\n                             (min-device-width: 768px) and (max-device-width: 1024px)  {\n                             table, thead, tbody, th, td, tr { display: block; }\n                             thead tr { position: absolute;top: -9999px;left: -9999px;}\n                             tr { border: 1px solid #9B9B9B; }\n                             td { border: none;border-bottom: 1px solid #9B9B9B; position: relative;padding-left: 50%; }\n                             td:before { position: absolute;top: 6px;left: 6px;width: 45%; padding-right: 10px; white-space: nowrap;}\n                             /*\n                             Label the data\n                             */\n                             td:nth-of-type(0):before { content: \"EMPLOYEE_ID\"; }\n                             td:nth-of-type(1):before { content: \"FIRST_NAME\"; }\n                             td:nth-of-type(2):before { content: \"LAST_NAME\"; }\n                             td:nth-of-type(3):before { content: \"SALARY\"; }\n                             }\n                             }\n                          </style>\n                          \x3c!--<![endif]--\x3e\n                       </head>\n                       <body>\n                          <h1 style = ''text-align :center; color:green;''>Employees Earning more than $10.000 Per/month</h1>\n                          <br>\n                          <table>\n                             <thead>\n                                <tr>\n                                   <th>EMPLOYEE_ID</th>\n                                   <th>FIRST_NAME</th>\n                                   <th>LAST_NAME</th>\n                                   <th>SALARY</th>\n                                </tr>\n                             </thead>\n                             <tbody id=\"data\">';\n    for r_top in cur_top_earning_emps loop\n        v_message := v_message|| '<tr>'||\n                                     '<td align=\"right\">'||r_top.employee_id||'</td>'||\n                                     '<td>'||r_top.first_name||'</td>'||\n                                     '<td>'||r_top.last_name||'</td>'||\n                                     '<td align=\"right\">'||r_top.salary||'</td>'||\n                                 '</tr>';\n\n    end loop;\n    v_message := v_message||'           </tbody>\n                                      </table>\n                                   </body>\n                                </html>';\n    UTL_MAIL.send(\n                  sender     => 'topearnings@somedns.com',\n                  recipients => 'oraclemaster@outlook.com',\n                  subject    => 'Example 5: The Employees Earning More Than $10000 (HTML Formatted)',\n                  message    => v_message,\n                  mime_type  => 'text/html'\n                 );\nEND;\n/\n------------------SEND ATTACH RAW------------\n\n--Create a temp table\nCREATE TABLE temp_table(\n  id        NUMBER,\n  blob_data BLOB\n);\n/\n--2) Create a directory object\nCREATE OR REPLACE DIRECTORY BLOB_DIR AS 'C:\\blob_directory\\';\n/\n--3)Write a PL/SQL Block to load your external file into a BLOB/CLOB column.\nDECLARE\n  v_bfile       BFILE;\n  v_blob        BLOB;\n  v_dest_offset INTEGER := 1;\n  v_src_offset  INTEGER := 1;\nBEGIN\n  INSERT INTO temp_table (id, blob_data)\n      VALUES (222,  empty_blob())\n          RETURNING blob_data INTO v_blob;\n\n  v_bfile := BFILENAME('BLOB_DIR', 'test_file.jpeg');\n  DBMS_LOB.fileopen(v_bfile, DBMS_LOB.file_readonly);\n  DBMS_LOB.loadblobfromfile (\n             dest_lob    => v_blob,              -- Destination lob\n             src_bfile   => v_bfile,             -- Source file path and name in the OS\n             amount      => DBMS_LOB.lobmaxsize, -- Maximum LOB size.\n             dest_offset => v_dest_offset,       -- Destination offset.\n             src_offset  => v_src_offset);       -- Source offset.\n  DBMS_LOB.fileclose(v_bfile);\n  COMMIT;\nEND;\n/\n--4) Check the table to see if we could insert the blob file or not\nSELECT * FROM temp_table;\n/\n--5) Send email with an attachment\nDECLARE\n    v_file BLOB;\n    v_rawbuf RAW(32767);\nBEGIN\n    select blob_data into v_file from temp_table where rownum = 1;\n    v_rawbuf := dbms_lob.substr(v_file);\n    UTL_MAIL.send_attach_raw -- Can attach only 1 file. If you need to send multiple attachments, you can use UTL_SMTP or Apex mail package\n    (\n        sender => 'somebody@somedomain.com',\n        recipients => 'oraclemaster@outlook.com',\n        subject => 'Example 6: Attachment Test',\n        message => 'This is a raw data',\n        attachment => v_rawbuf,\n        att_inline => TRUE,\n        att_filename => 'testImage.jpeg'\n    );\nEND;\n/\nDROP DIRECTORY blob_dir;\nDROP TABLE temp_table;\n/\n--5) Send email with a text attachment\nBEGIN\n    UTL_MAIL.send_attach_varchar2\n    (\n        sender => 'somebody@somedomain.com',\n        recipients => 'oraclemaster@outlook.com',\n        subject => 'Example 7: Text Attachment Test',\n        message => 'This is a text data',\n        attachment => 'This is the text that will be written inside of the text file.',\n        att_inline => TRUE,\n        att_filename => 'testTextFile.txt'\n    );\nEND;\n")),(0,l.kt)("h2",{id:"utl_file"},"UTL_FILE"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"In Oracle PL/SQL, ",(0,l.kt)("inlineCode",{parentName:"li"},"UTL_FILE")," is an Oracle supplied package which is used for file operations (read and write) in conjunction with the underlying operating system."),(0,l.kt)("li",{parentName:"ul"},"UTL_FILE_DIR is not used by anyone anymore. UTL_FILE_DIR lets you specify one or more directories that Oracle should use for PL/SQL file I/O. If you are specifying multiple directories, you must repeat the UTL_FILE_DIR parameter for each directory on separate lines of the initialization parameter file.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\n    tc_logfile UTL_FILE.FILE_TYPE;\n    filedir VARCHAR2(10);\n    v_dir VARCHAR2(100);\n    read_line VARCHAR2(200);\nBEGIN\n    filedir := 'E:\\';\n    v_dir := 'CREATE OR REPLACE DIRECTORY TEMP_TEXT as '''|| filedir||'''';\n    EXECUTE IMMEDIATE v_dir;\n    tc_logfile := UTL_FILE.FOPEN('TEMP_TEXT','TestFile.txt','W'); --A to append; W to write; R to read; RB- Read Binary; WB - Write Binary;AB - Append Binary\n    UTL_FILE.PUT_LINE(tc_logfile, 'STARTING..' || SYSTIMESTAMP);\n    UTL_FILE.PUT_LINE(tc_logfile, 'This is a test file');\n\n    IF UTL_FILE.IS_OPEN(tc_logfile) THEN\n        UTL_FILE.FCLOSE(tc_logfile);\n    END IF;\n    tc_logfile := UTL_FILE.FOPEN('TEMP_TEXT','TestFile.txt','R');\n\n    LOOP\n        BEGIN\n            UTL_FILE.GET_LINE(tc_logfile,read_line);\n            DBMS_OUTPUT.PUT_LINE(read_line);\n        EXCEPTION\n            WHEN NO_DATA_FOUND THEN\n            EXIT;\n        END;\n    END LOOP;\n\n    UTL_FILE.FCLOSE(tc_logfile);\nEND;\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"--------------------CREATE DIRECTORY------------------------------------\nCREATE DIRECTORY test_dir AS 'C:\\My Folder'; -- Alias for the directory\n/\n-------------------GET ALL THE EXISTING DIRECTORIES--------------------\nSELECT * FROM all_directories;\n/\n-------------------READ FROM A FILE------------------------------------\nSET SERVEROUTPUT ON;\nDECLARE\n    v_file UTL_FILE.FILE_TYPE;\n    v_line VARCHAR2(32767);\nBEGIN\n    v_file := UTL_FILE.FOPEN('TEST_DIR', 'temp file.txt', 'R', 32767); -- Directory name should be specified in UPPER case when using in UTL_FILE. Because it is stored in all_directories with upper case\n    -- 32767 is the max line size\n    LOOP\n        UTL_FILE.GET_LINE(v_file, v_line); -- 3 parameters can be passed here. Ex: UTL_FILE.GET_LINE(v_file, v_line,10); -- 10 means read 10 characters per loop. So, if there are 20 characters in each line, it will read first 10 first then in second loop, reads the rest.\n        dbms_output.put_line (v_line);\n    END LOOP; -- After reading all lines, it raises no_data_found exception\n    EXCEPTION\n        WHEN no_data_found THEN\n            dbms_output.put_line('The whole file is read!');\n            UTL_FILE.FCLOSE(v_file); -- FCLOSE_ALL - Closes all open files that used in that session; Can use it in exception to close everything if error happens; If you close files with this procedure, IS_OPEN will return TRUE even if all the files are closed.\nEND;\n/\n-------------------GRANT OR REVOKE READ-WRITE PRIVILEGES---------------\nGRANT READ, WRITE ON DIRECTORY test_dir TO hr;\nREVOKE READ, WRITE ON DIRECTORY test_dir FROM hr;\n/\n-------------------WRITE TO A FILE USING PUT_LINE PROCEDURE-------------\nDECLARE\n    v_file UTL_FILE.FILE_TYPE;\nBEGIN\n    v_file := UTL_FILE.FOPEN('TEST_DIR', 'temp file.txt', 'w', 32767); -- Maximum number of file open simultaneously is 50\n    FOR r_emp IN (select * from employees) LOOP\n        UTL_FILE.PUT_LINE(v_file, r_emp.first_name||' '||r_emp.last_name); -- write with new line character. This takes 3 parameters. 3rd one is a boolean value for AUTOFLUSH(automatically flush data from memory into disk/file). Useful when debugging the code. Otherwise it will flush when the file is closed (FCLOSE) and AUTOFLUSH will enable to see realtime writing into the file.\n    END LOOP;\n    UTL_FILE.FCLOSE(v_file);\nEND;\n/\n-------------------WRITE TO A FILE USING PUT AND NEW_LINE---------------\nDECLARE\n    v_file UTL_FILE.FILE_TYPE;\nBEGIN\n    v_file := UTL_FILE.FOPEN('TEST_DIR', 'temp file.txt', 'w', 32767);\n    FOR r_emp IN (select * from employees) LOOP\n        UTL_FILE.PUT(v_file, r_emp.first_name||' '||r_emp.last_name); -- without new line character\n        UTL_FILE.NEW_LINE(v_file); -- New line character; 2 parameters can be passed here. Ex: UTL_FILE.NEW_LINE(v_file,10); -- 10 means add 10 new line characters into the file. Default is 1\n    END LOOP;\n    UTL_FILE.FCLOSE(v_file);\nEND;\n/\n-------------------WRITE TO A FILE USING PUTF---------------------------\nDECLARE\n    v_file UTL_FILE.FILE_TYPE;\nBEGIN\n    v_file := UTL_FILE.FOPEN('TEST_DIR', 'temp file.txt', 'w', 32767);\n    FOR r_emp IN (select * from employees) LOOP\n        UTL_FILE.PUTF(v_file, '--\x3e %s %s',r_emp.first_name,r_emp.last_name);--provides formatted put procedure\n        --UTL_FILE.NEW_LINE(v_file);\n        --UTL_FILE.PUTF(v_file, '--\x3e %s %s\\n',r_emp.first_name,r_emp.last_name);--\\n for new line\n    END LOOP;\n    UTL_FILE.FCLOSE(v_file);\nEND;\n/\n-------------------USING FFLUSH TO WRITE IMMEDIATELY-------------------\nDECLARE\n    v_file UTL_FILE.FILE_TYPE;\nBEGIN\n    v_file := UTL_FILE.FOPEN('TEST_DIR', 'temp file.txt', 'w', 32767);\n    FOR r_emp IN (select * from employees) LOOP\n        UTL_FILE.PUT_LINE(v_file,r_emp.first_name||' '||r_emp.last_name);\n        --UTL_FILE.FFLUSH(v_file); --Writes buffered data(data in memory) into disk/file\n        --UTL_FILE.PUT_LINE(v_file,r_emp.first_name||' '||r_emp.last_name,true);\n        DBMS_SESSION.SLEEP(1);\n    END LOOP;\n    UTL_FILE.FCLOSE(v_file);\nEND;\n/\n-------------------CHECK FILE ATTRIBUTES-----------------------------\nDECLARE\n    v_fexists       BOOLEAN;\n    v_file_length   NUMBER;\n    v_block_size    BINARY_INTEGER; -- Not the block size of the file. It is the block size of the file system. So not useful\nBEGIN\n    UTL_FILE.FGETATTR('TEST_DIR','temp file.txt',v_fexists,v_file_length,v_block_size);\n    IF v_fexists THEN\n        DBMS_OUTPUT.PUT_LINE('The file exists');\n        DBMS_OUTPUT.PUT_LINE('Its length is     :'||v_file_length);\n        DBMS_OUTPUT.PUT_LINE('Its block size is :'||v_block_size); -- In windows it shows 0 in Linux it shows the block size\n    ELSE\n        DBMS_OUTPUT.PUT_LINE('The file does not exist!');\n    END IF;\nEND;\n/\n-------------------COPY THE FILE---------------------------------------\nEXECUTE UTL_FILE.FCOPY('TEST_DIR','temp file.txt','TEST_DIR','temp file copy.txt'); -- \"temp file\" is the file name with space between\n/\n-------------------COPY THE FILE EX2-----------------------------------\nEXECUTE UTL_FILE.FCOPY('TEST_DIR','temp file.txt','TEST_DIR','temp file copy2.txt',1,5);--Copy line 1 to 5\n/\n-------------------RENAME THE FILE-------------------------------------\nEXECUTE UTL_FILE.FRENAME('TEST_DIR','temp file copy2.txt','TEST_DIR','temp file renamed.txt');\nEXECUTE UTL_FILE.FRENAME('TEST_DIR','temp file copy2.txt','TEST_DIR','temp file renamed.txt',TRUE); -- TRUE means to replace existing file or not\n/\n-------------------REMOVE THE FILE-------------------------------------\nEXECUTE UTL_FILE.FREMOVE('TEST_DIR','temp file renamed.txt');\nEXECUTE UTL_FILE.FREMOVE('TEST_DIR','temp file copy.txt');\nEXECUTE UTL_FILE.FREMOVE('TEST_DIR','temp file.txt');\n/\n-------------------DROP THE DIRECTORY-----------------------------------\nDROP DIRECTORY test_dir;\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Other procedure in UTL_FILE",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"FOPEN_NCHAR: Opens a file in Unicode for input or output."),(0,l.kt)("li",{parentName:"ul"},"FGETPOS: Returns the current relative offset position within a file in bytes."),(0,l.kt)("li",{parentName:"ul"},"FSEEK: Adjusts the file pointer forward or backward within the file."),(0,l.kt)("li",{parentName:"ul"},"GET_LINE_NCHAR: Retrieves a line from the file in Unicode form."),(0,l.kt)("li",{parentName:"ul"},"GET_RAW: Reads a raw string value from a file."),(0,l.kt)("li",{parentName:"ul"},"PUT_LINE_NCHAR: Writes a Unicode string to a file with the newline character."),(0,l.kt)("li",{parentName:"ul"},"PUT_NCHAR: Writes a Unicode string to a file without the newline character."),(0,l.kt)("li",{parentName:"ul"},"PUTF_NCHAR: Provides formatted put nchar procedure."),(0,l.kt)("li",{parentName:"ul"},"PUT_RAW: Writes RAW data value to a file.")))),(0,l.kt)("h2",{id:"external-tables"},"External tables"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE OR REPLACE DIRECTORY directory_name AS 'C\\Users'; --Directory object\n\nCREATE TABLE students(name VARCHAR2(20),college VARCHAR2(20), major VARCHAR2(20))\nORGANIZATION EXTERNAL(\n    TYPE ORACLE_LOADER\n    --The ORACLE_LOADER access driver is the default. It can perform only data loads, and the data must come from text datafiles. Loads from external tables to internal tables are done by reading from the external tables' text-only datafiles.\n    --The ORACLE_DATAPUMP access driver can perform both loads and unloads. The data must come from binary dump files. Loads to internal tables from external tables are done by fetching from the binary dump files. Unloads from internal tables to external tables are done by populating the external tables' binary dump files.\n    DEFAULT DIRECTORY directory_name\n    ACCESS PARAMETERS (\n        RECORD DELIMITED BY NEWLINE\n        FIELDS TERMINATED BY ',' --comma separated\n        MISSING FIELD VALUE ARE NULL --if any data is missing, add them as NULL\n            ( name CHAR(20),\n            collage CHAR(20),\n            major CHAR(20)\n            )\n        )\n    LOCATION ('major.txt') --filename\n)\nREJECT LIMIT UNLIMITED; --stop the process if error comes more than specified value.\n")),(0,l.kt)("h2",{id:"import-data-from-excel-to-oracle-using-sql-developer"},"Import data from Excel to Oracle using SQL Developer"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Right click the table you want to insert data -> select import data -> select excel file -> click open")),(0,l.kt)("h2",{id:"xmlelement"},"XMLELEMENT"),(0,l.kt)("p",null,"The XMLELEMENT function is the basic unit for turning column data into XML fragments."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},'SQL> SELECT XMLELEMENT("name", e.first_name) AS employee FROM HR.employees e\nWHERE e.employee_id = 160;\n--------------------------------------------------------------------------------\n<name>Louise</name>\n----\nSQL> SELECT XMLELEMENT("employee",\n        XMLELEMENT("employee_no", e.employee_id),\n        XMLELEMENT("name", e.first_name)\n        ) AS employee\n    FROM employees e\n    WHERE e.employee_id = 160;\n--------------------------------------------------------------------------------\n<employee><employee_no>160</employee_no><name>Louise</name></employee>\n----\nSQL> SELECT XMLELEMENT("employee",\n        XMLATTRIBUTES( --XMLATRIBUTES function converts column data into attributes of the parent element\n            e.employee_id AS "employee_id",\n            e.first_name AS "name")\n        ) AS employee\n    FROM employees e\n    WHERE e.employee_id = 160;\n--------------------------------------------------------------------------------\n<employee employee_id="160" name="Louise"></employee>\n----\nSQL> SELECT XMLELEMENT("employee",\n            XMLFOREST( --Like XMLATTRIBUTES, the XMLFOREST function allows you to process multiple columns at once.\n            e.employee_id AS "employee_id",\n            e.first_name AS "name")\n        ) AS employee\n    FROM employees e\n    WHERE e.employee_id = 160;\n--------------------------------------------------------------------------------\n<employee><employee_id>160</employee_id><name>Louise</name></employee>\n----\nSQL> SELECT XMLAGG( --XMLAGG function allows to aggregate separate fragments(multiple rows of data) into a single fragment\n        XMLELEMENT("emp",\n            XMLFOREST(\n            e.employee_id AS "empid",\n            e.first_name AS "name")\n        )\n    ) AS employees\n    FROM employees e\n    WHERE e.department_id = 50;\n-----------------------------------------------------------------\n<emp><empid>120</empid><name>Matthew</name></emp><emp><empid>121</empid><name>Adam</name></emp><emp><empid>122</empid><name>Payam</name></emp><emp><empid>123</empid><name>Shanta</name></emp><emp><empid>123</empid><name>Kevin</name></emp>\n')),(0,l.kt)("h2",{id:"sql-loader"},"SQL Loader"),(0,l.kt)("p",null,"SQL","*","Loader is a bulk loader utility used for moving data from external files into the Oracle database.\nSQL Loader Control File"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"LOAD DATA\nINFILE 'C:\\text_file.csv' --input file\nBADFILE 'C:\\textfile_bad.bad' --contains the records that are rejected by sql loader or oracle database becuase of invalid format. After a data is accepted by sql loader, it is sent to oracle database for insertion\nDISCARDFILE 'C:\\textfile_discard.dis' --records which are filtered out of the load because they don't meet the criteria specified in WHEN clause\nTRUNCATE INTO TABLE table_name --TRUNCATE to delete previous data in table\n--INSERT: Loads only if the target table is empty\n--APPEND: Loads rows if the target table is empty or not\n--REPLACE: First it delete the rows in the existing table and then loads the data\n--TRUNCATE: First it truncate the table and then loads the data\nWHEN OBJECT_TYPE <> 'INDEX' --i don't need any record with 'INDEX' in it\nFIELDS TERMINATED BY \",\" OPTIONALLY ENCLOSED BY \"#\" --delimited by , or #\nTRAILING NULL COLS --if the last column is empty, then treat this as NULL value; otherwise SQL Loader will treat this record as bad if the last column is empty\n(deptno, --column names in table\ndname,\njdate date'mm/dd/yyyy', --formating the date\nloc\"TRIM(:OBJECT_TYPE)\") --TRIM the white space if any\nor\n(deptno position(1:3), dname position(4:8), jdate position(9:18), loc position(19:22))\nor\n(deptno \"deptno+100\", --add 100 to the deptno\ndname \"upper(:dname)\", --upper case\njdate,\nloc \"decode(:loc,'Delhi','New Delhi',:loc)\")\nsqlldr control=C:\\textfile_control.ctl log=C:\\textfile_log.log --given the datafile in INFILE of control file\nor\nsqlldr datafile=C:\\text_file.csv control=C:\\textfile_control.ctl log=C:\\textfile_log.log\n")),(0,l.kt)("h2",{id:"local-screening"},"Local Screening"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"If there are two variables with same name in the outer and inner block, and if we call the variable from inside the block, italways prefer the local (inner) variable. To refer to the outer variable, we need to use label.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"<<out_label>>\nDECLARE\n    x NUMBER := 100;\nBEGIN\n    FOR x IN 1..10 LOOP\n        DBMS_OUTPUT.PUT_LINE(out_label.x);\n    END LOOP;\nEND;\n")),(0,l.kt)("h2",{id:"wrapped"},"Wrapped"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Wrapping is the process of hiding PL/SQL source code."),(0,l.kt)("li",{parentName:"ul"},"Wrapping helps to protect your source code from business competitors and others who might misuse it."),(0,l.kt)("li",{parentName:"ul"},"Wrapped source files can be moved, backed up, and processed by SQL",(0,l.kt)("em",{parentName:"li"},"Plus and the Import and Export utilities, but they are not visible through the static data dictionary views "),"_","SOURCE."),(0,l.kt)("li",{parentName:"ul"},"You cannot edit PL/SQL source code inside wrapped files. Either wrap your code after it is ready to ship to users or include the wrapping operation as part of your build environment."),(0,l.kt)("li",{parentName:"ul"},"To change wrapped PL/SQL code, edit the original source file and then wrap it again."),(0,l.kt)("li",{parentName:"ul"},"Wrapping is not a secure method for hiding passwords or table names."),(0,l.kt)("li",{parentName:"ul"},"To hide the workings of a trigger, write a one-line trigger that invokes a wrapped subprogram."),(0,l.kt)("li",{parentName:"ul"},"Wrapping does not detect syntax or semantic errors."),(0,l.kt)("li",{parentName:"ul"},"Wrapped PL/SQL units are not downward-compatible.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"CMD> wrap iname=\"wrap_test.sql\" --wrap_test.sql is the file name of a procedure (no space between the equal sign)\nPL/SQL Wrapper: Release 18.0.0.0.0 -Production on Thu Aug 1 16:26:09 2019\nVersion 18.3.0.0.0\nCopyright (c) 1982, 2018, Oracle and/or its affiliates. All rights reserved.\nProcessing wrap_test.sql to wrap_test.plb --output file\nSQL> @wrap_test.plb\nSQL> call wraptest();\n----\nDECLARE\n    PACKAGE_TEXT VARCHAR2(32767) := 'CREATE PACKAGE emp_actions AS\n    PROCEDURE raise_salary (emp_id NUMBER, amount NUMBER);\n    PROCEDURE fire_employee (emp_id NUMBER);\nEND emp_actions;';\n\nBEGIN\n    DBMS_DDL.CREATE_WRAPPED(PACKAGE_TEXT);\nEND;\n")),(0,l.kt)("h2",{id:"dbms-packages"},"DBMS Packages"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The DBMS_SQL(",(0,l.kt)("strong",{parentName:"li"},"The Method 4"),") package provides an interface to use dynamic SQL to parse any data manipulation language (DML) or data definition language (DDL) statement using PL/SQL."),(0,l.kt)("li",{parentName:"ul"},"Native Dynamic SQL(EXECUTE IMMEDIATE) is an alternative to DBMS_SQL that lets you place dynamic SQL statements directly into PL/SQL blocks."),(0,l.kt)("li",{parentName:"ul"},"In most situations, Native Dynamic SQL is easier to use and performs better than ",(0,l.kt)("inlineCode",{parentName:"li"},"DBMS_SQL"),"."),(0,l.kt)("li",{parentName:"ul"},"However, Native Dynamic SQL itself has certain limitations"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"DBMS_SQL.NATIVE")," --Specifies normal behaviour for the database to which the program is connected. Can define behaviour as in Oracle version 6 and 7"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"DBMS_SQL.OPEN_CURSOR")," -- Opens a new cursor and returns the cursor ID"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"DBMS_SQL.PARSE")," --Parsing the statement checks the statement's syntax and associates it with the cursor in your program. You can parse any DML or DDL statement. DDL statements are run on the parse, which performs the implied commit.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"DBMS_SQL.PARSE(cursor_id, statement, edition)"),(0,l.kt)("li",{parentName:"ul"},"Edition: - 0 or V6 -> Database V6 ; 1 or NATIVE -> Default ; 2 or V7 -> Database V7 ; FOREIGN_SYNTAX -> Non oracle database syntax"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"DBMS_SQL.BIND_VARIABLE")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"DBMS_SQL.DEFINE_COLUMN")," --The columns of the row being selected in a ",(0,l.kt)("inlineCode",{parentName:"li"},"SELECT")," statement are identified by their relative positions as they appear in the select list, from left to right"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"DBMS_SQL.EXECUTE")," --Call the EXECUTE function to run your SQL statement and returns the number of rows processed",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"DBMS_SQL.EXECUTE(cursor_id)"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"DBMS_SQL.FETCH_ROWS")," --The ",(0,l.kt)("inlineCode",{parentName:"li"},"FETCH_ROWS")," function retrieves the rows that satisfy the query.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"DBMS_SQL.FETCH_ROWS(cursor_id)"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"DBMS_SQL.COLUMN_VALUE")," --call ",(0,l.kt)("inlineCode",{parentName:"li"},"COLUMN_VALUE")," after fetching rows to actually retrieve the values of the columns in the rows into your program"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"DBMS_SQL.VARIABLE_VALUE")," --call ",(0,l.kt)("inlineCode",{parentName:"li"},"VARIABLE_VALUE")," to retrieve the value of an OUT parameter for an anonymous block"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"DBMS_SQL.CLOSE_CURSOR")," --Closes the cursor; (Native dynamic SQL closes cursor itself)",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"DBMS_SQL.CLOSE_CURSOR(cursor_id)")))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE employees_copy AS SELECT * FROM employees;\n\n/\nset serveroutput on;\nDECLARE\n    v_table_name VARCHAR2(20) := 'employees_copy';\n    v_cursor_id PLS_INTEGER;\n    v_affected_rows PLS_INTEGER;\nBEGIN\n    v_cursor_id := dbms_sql.open_cursor;\n    dbms_sql.parse(v_cursor_id, 'update '||v_table_name||' set salary=salary+500',dbms_sql.NATIVE);\n    v_affected_rows := dbms_sql.EXECUTE(v_cursor_id);\n    dbms_output.put_line(v_affected_rows|| ' rows are updated by dbms_sql!');\n    dbms_sql.close_cursor(v_cursor_id);\nEND;\n\n/\n\nselect * from employees_copy;\n\n/\n\nDECLARE\n    v_table_name varchar2(20) := 'employees_copy';\n    v_cursor_id pls_integer;\n    v_affected_rows pls_integer;\nBEGIN\n    v_cursor_id := DBMS_SQL.OPEN_CURSOR;\n    DBMS_SQL.PARSE(v_cursor_id, 'update '||v_table_name||' set salary=salary+500 WHERE job_id = :jid',DBMS_SQL.NATIVE);\n    DBMS_SQL.BIND_VARIABLE(v_cursor_id, ':jid','IT_PROG');\n    v_affected_rows := DBMS_SQL.EXECUTE(v_cursor_id);\n    dbms_output.put_line(v_affected_rows|| ' rows are updated by dbms_sql!');\n    DBMS_SQL.CLOSE_CURSOR(v_cursor_id);\nEND;\n\n/\n\nDECLARE\n    v_table_name varchar2(20) := 'employees_copy';\n    v_cursor_id pls_integer;\n    v_affected_rows pls_integer;\nBEGIN\n    v_cursor_id := DBMS_SQL.OPEN_CURSOR;\n    DBMS_SQL.PARSE(v_cursor_id, 'update '||v_table_name||' set salary=salary+:inc WHERE job_id = :jid',DBMS_SQL.NATIVE);\n    DBMS_SQL.BIND_VARIABLE(v_cursor_id, ':jid','IT_PROG');\n    DBMS_SQL.BIND_VARIABLE(v_cursor_id, ':inc','5');\n    v_affected_rows := DBMS_SQL.EXECUTE(v_cursor_id);\n    dbms_output.put_line(v_affected_rows|| ' rows are updated by dbms_sql!');\n    DBMS_SQL.CLOSE_CURSOR(v_cursor_id);\nEND;\n\n/\n\nSELECT * FROM user_tab_columns;\nEXEC prc_method4_example('employees');\nEXEC prc_method4_example('departments');\nEXEC prc_method4_example('countries');\nEXEC prc_method4_example('locations');\n/\n\ncreate or replace PROCEDURE prc_method4_example (p_table_name IN VARCHAR2) IS\n    TYPE t_columns IS TABLE OF user_tab_columns%rowtype INDEX BY PLS_INTEGER;\n    v_columns               t_columns;\n    v_columns_with_commas   VARCHAR2(32767);\n    v_number_value          NUMBER;\n    v_string_value          VARCHAR2(32767);\n    v_date_value            DATE;\n    v_output_string         VARCHAR2(32767);\n    cur_dynamic             INTEGER;\nBEGIN\n    SELECT * BULK COLLECT INTO v_columns FROM user_tab_columns WHERE table_name = upper(p_table_name);\n    v_columns_with_commas:=v_columns(1).column_name;\n    FOR i IN 2..v_columns.COUNT LOOP\n        v_columns_with_commas:=v_columns_with_commas||','||v_columns(i).column_name;\n    END LOOP;\n    cur_dynamic := dbms_sql.open_cursor;\n    dbms_sql.parse(cur_dynamic,'SELECT '||v_columns_with_commas||' FROM '||p_table_name,dbms_sql.NATIVE);\n     FOR idx IN 1..v_columns.COUNT LOOP\n        IF v_columns(idx).data_type = 'NUMBER' THEN\n            dbms_sql.define_column(cur_dynamic,idx,1);\n        ELSIF v_columns(idx).data_type IN ('VARCHAR2','VARCHAR','CHAR') THEN\n            dbms_sql.define_column(cur_dynamic,idx,'dummy text',v_columns(idx).char_length);\n        ELSIF v_columns(idx).data_type = 'DATE' THEN\n            dbms_sql.define_column(cur_dynamic,idx,sysdate);\n        END IF;\n        v_output_string:=v_output_string||'  '||rpad(v_columns(idx).column_name,20);\n     END LOOP;\n     dbms_output.put_line(v_output_string);\n     v_number_value:=dbms_sql.execute(cur_dynamic);\n     WHILE dbms_sql.fetch_rows(cur_dynamic) > 0 LOOP\n        v_output_string:=NULL;\n        FOR t IN 1..v_columns.COUNT LOOP\n            IF v_columns(T).data_type = 'NUMBER' THEN\n                dbms_sql.column_value(cur_dynamic,t,v_number_value);\n                v_output_string := v_output_string||'  '||rpad(nvl(to_char(v_number_value),' '),20);\n            ELSIF v_columns(T).data_type IN ('VARCHAR2','VARCHAR','CHAR') THEN\n                dbms_sql.column_value(cur_dynamic,t,v_string_value);\n                v_output_string := v_output_string||'  '||rpad(nvl(to_char(v_string_value),' '),20);\n            ELSIF v_columns(T).data_type = 'DATE' THEN\n                dbms_sql.column_value(cur_dynamic,t,v_date_value);\n                v_output_string := v_output_string||'  '||rpad(nvl(to_char(v_date_value),' '),20);\n            END IF;\n        END LOOP;\n        dbms_output.put_line(v_output_string);\n     END LOOP;\nEND;\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The ",(0,l.kt)("inlineCode",{parentName:"p"},"DBMS_RANDOM")," package provides a built-in random number generator. DBMS_RANDOM is not intended for cryptography.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"DBMS_RANDOM.VALUE"),"(low_value,high_value) --gets a random number with 38 digit decimal")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"DBMS_RANDOM.STRING"),"(single_character,length) --This function gets a random string.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"DBMS_LOCK.SLEEP(120)")," --This procedure suspends the session for a given period of time (seconds).")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"DBMS_UTILITY.FORMAT_ERROR_BACKTRACE")," --This function displays the call stack at the point where an exception was raised, even if the subprogram is called from an exception handler in an outer scope")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"DBMS_UTILITY.FORMAT_ERROR_STACK")," - This function formats the current error stack. This can be used in exception handlers to look at the full error stack. SQLERRM in principle gives the same info as FORMAT_ERROR_STACK. But SQLERRM is subject to some length limits, while FORMAT_ERROR_STACK is not.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"DBMS_UTILITY.GET_TIME"),"\n-This function determines the current time in 100th's of a second."),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"This subprogram is primarily used for determining elapsed time."),(0,l.kt)("li",{parentName:"ul"},"The subprogram is called twice \u2013at the beginning and end of some process \u2013and then the first (earlier) number is subtracted from the second (later) number to determine the time elapsed."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"DBMS_UTILITY.GET_CPU_TIME")," --CPU time")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"DBMS_OUTPUT.PUT_LINE"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"DBMS_OUTPUT.PUT_LINE($$PLSQL_LINE);")," --Displays line number")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"DBMS_OUTPUT.DISABLE")))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"EXEC dbms_output.put_line('Test No:1');\n/\nSET SERVEROUTPUT ON; -- This also uses dbms_output.get_line procedure. So, if it does not have new line, it will not print\nEXEC dbms_output.put_line('Test No:2');\n/\nEXEC dbms_output.put('Test No:3');\n/\nEXEC dbms_output.put_line('Test No:4');\n/\nSET SERVEROUTPUT OFF\n/\nCREATE TABLE temp_table(ID NUMBER GENERATED ALWAYS AS IDENTITY, text VARCHAR2(1000));\n/\nEXEC dbms_output.enable; -- Enables buffer\nEXEC dbms_output.put_line('Hi');\n/\nDECLARE\n    v_buffer VARCHAR2(1000);\n    v_status INTEGER;\nBEGIN\n    dbms_output.put('...');\n    dbms_output.put_line('Hello');\n    dbms_output.put_line('How are you');\n    FOR I IN 1..10 LOOP\n        dbms_output.get_line(v_buffer,v_status); -- Read from buffer into v_buffer(data) and v_status(status)\n        IF v_status = 0 THEN -- 0 means it read a line\n            INSERT INTO temp_table(text) VALUES (v_buffer);\n        END IF;\n    END LOOP;\nEND;\n/\nSELECT * FROM temp_table;\n/\nSET SERVEROUTPUT ON;\nDECLARE\n    v_buffer VARCHAR2(1000);\n    v_status INTEGER;\nBEGIN\n    dbms_output.put('...');\n    dbms_output.put_line('Hello');\n    dbms_output.put_line('How are you');\n    dbms_output.get_line(v_buffer,v_status);\nEND;\n/\nSET SERVEROUTPUT OFF;\nEXEC dbms_output.enable;\n/\nDECLARE\n    v_buffer dbms_output.chararr; -- Inbuilt character array\n    v_num_lines INTEGER:= 30;\nBEGIN\n    dbms_output.put('...');\n    dbms_output.put_line('Hello');\n    dbms_output.put_line('How are you');\n    dbms_output.get_lines(v_buffer,v_num_lines);\n    FOR i IN 1..v_num_lines LOOP\n        INSERT INTO temp_table(text) VALUES (v_buffer(I));\n    END LOOP;\nEND;\n/\nDROP TABLE temp_table;\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"DBMS_STATS.GATHER_TABLE_STATS")," --This procedure gathers table and column (and index) statistics.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"EXEC DBMS_STATS.GATHER_SCHEMA_STATS(USER, CASCADE => TRUE);\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"DBMS_XPLAN.DISPLAY")," --to format and display the contents of a plan table.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"DBMS_XPLAN.DISPLAY_AWR")," --to format and display the contents of the execution plan of a stored SQL statement in the AWR.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"DBMS_XPLAN.DISPLAY_CURSOR")," --to format and display the contents of the execution plan of any loaded cursor.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"DBMS_METADATA.GET_DDL")))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT DBMS_METADATA.GET_DDL ('TABLE', 'EMPLOYEES', 'HR') FROM DUAL;\n--to get DDL for a view just replace first argument with \u2018VIEW\u2019 and second with your view name and so.\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"DBMS_REFRESH.ADD")," --Adds materialized views to a refresh group.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"DBMS_REFRESH.MAKE")," --To make materialized view refresh group")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"DBMS_REFRESH.CHANGE")," --Changes the refresh interval for a refresh group.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"DBMS_REFRESH.DESTROY")," --Removes all of the materialized views from a refresh group and deletes the refresh group.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"DBMS_REFRESH.REFRESH")," --Manually refreshes a refresh group.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"DBMS_REFRESH.SUBTRACT")," --Removes materialized views from a refresh group.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"DBMS_MVIEW.REFRESH")," --Refreshes one or more materialized views that are not members of the same refresh group")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"DBMS_MVIEW.REFRESH_ALL_MVIEWS")," --Refreshes all materialized views"))),(0,l.kt)("h2",{id:"table-clusters"},"Table Clusters"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"A table cluster is a group of tables that share common columns and store related data in the same blocks."),(0,l.kt)("li",{parentName:"ul"},"When tables are clustered, a single data block can contain rows from multiple tables. For example, a block can store rows from both the employees and departments tables rather than from only a single table."),(0,l.kt)("li",{parentName:"ul"},"The cluster key is the column or columns that the clustered tables have in common. For example, the employees and departments tables share the department_id column. You specify the cluster key when creating the table cluster and when creating every table added to the table cluster."),(0,l.kt)("li",{parentName:"ul"},"The cluster key value is the value of the cluster key columns for a particular set of rows. All data that contains the same cluster key value, such as department_id=20, is physically stored together."),(0,l.kt)("li",{parentName:"ul"},"Consider clustering tables when they are primarily queried (but not modified) and records from the tables are frequently queried together or joined. This benefits reduced Disk I/O for joins, improves access time for joins."),(0,l.kt)("li",{parentName:"ul"},"Flashback Table operation is not supported on clustered tables")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"/*For example to create a cluster of EMP and DEPT tables in which the DEPTNO will be cluster key, first create the cluster by typing the following command.*/\nCREATE CLUSTER emp_dept (deptno NUMBER(2));\n\n/*Then create index on it.*/\nCREATE INDEX idx_empdept ON CLUSTER emp_dept;\n\n/*Now create table in the cluster like this*/\nCREATE TABLE dept (deptno NUMBER(2),\n    name VARCHAR2(20),\n    loc VARCHAR2(20))\n    CLUSTER emp_dept (deptno);\n    CREATE TABLE emp (empno NUMBER(5),\n    name VARCHAR2(20),\n    sal NUMBER(10,2),\n    deptno NUMBER(2))\n\nCLUSTER emp_dept (deptno);\n")),(0,l.kt)("h2",{id:"debugging"},"Debugging"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"SQL developer uses DBMS_DEBUG package or JDWP(Java Debug Wire Protocol) is used to debug PLSQL blocks. Need to grant execution permission inorder to do that."),(0,l.kt)("li",{parentName:"ul"},"To debug an object, we need to compile it for debug."),(0,l.kt)("li",{parentName:"ul"},'"Compile for debug" will add significant overhead to the object. Database collects so much information and stores in memory. You need to recompile with normal "Compile" after debugging the code.'),(0,l.kt)("li",{parentName:"ul"},'Do not use "Compile for debug" in production environment. There will be significant performance loss. Object will be locked and no one can use it.')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"GRANT DEBUG CONNECT SESSION TO hr;\nGRANT DEBUG ANY PROCEDURE TO hr;\n\nBEGIN\n    dbms_network_acl_admin.append_host_ace\n         (host=>'127.0.0.1',\n          ace => sys.xs$ace_type(privilege_list => sys.xs$name_list('JDWP'),\n                                 principal_name => 'HR',\n                                 principal_type => sys.xs_acl.ptype_db) );\nEND;\n")))}E.isMDXComponent=!0}}]);